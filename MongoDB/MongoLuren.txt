https://www.canva.com/design/DAGNfeKTz_Q/nJB6OKFDJxFxiAxklMrVXw/edit
https://www.canva.com/design/DAGMvEWWNiA/45pt6qAw4b5LyswAqKLRPA/edit

Q1. What happens if you try insertMany([]) with an empty array?
Answer: It throws MongoInvalidArgumentError: Invalid BulkOperation, Batch cannot be empty because MongoDB requires at least one document.

Q2. What’s the correct command to view all documents from a collection named Teacher?
Answer: db.Teacher.find()

Q3. What will happen if you try db.Studnt.find() but only student collection exists?
Answer: It returns nothing (empty array) because there is no collection named Studnt.

Q4. Is show collections.Teacher a valid MongoDB command?
Answer: ❌ No. You should use show collections and then query using db.Teacher.find().

Q5. After switching to a database using use test, why doesn’t it show up in show dbs?
Answer: A database is not actually created until you insert at least one document in it.

# _id field - Automatically generated by MongoDB as the unique identifier for each document.
# Case Sensitivity - Collection names are case-sensitive: Teacher ≠ teacher.
# If you ever want to pretty-print the find() result: - test> db.Teacher.find().pretty()
# {} (empty filter)	Everything!	Dangerous — use with caution

Summary of Key Learnings:
Command	-Purpose	-Notes
db.collection.insertOne()    -  Insert a single document   -  Must provide a valid JSON object
db.collection.insertMany([]) - Insert multiple documents -   ❌ Fails if array is empty
show collections	     - Lists all collection names	-    ✅ No chaining allowed
db.collection.find()	- Shows documents from collection	 - Case-sensitive and typo-sensitive
use <db>	 -        Switches database	-    Doesn’t create it unless insert occurs


Basic Syntax
The find() method takes two optional arguments:

query (or filter): A document that specifies the selection criteria (which documents to return). If omitted or an empty document ({}), all documents in the collection are returned.

projection: A document that specifies which fields to include or exclude from the returned documents.

The general syntax is:

db.collection.find(query, projection)

MongoDB Update Operators Cheat Sheet:
Operator	  Meaning
$set	      Add new field or update value
$unset	    Remove field
$inc	      Increment numeric value
$rename	    Rename a field
$mul	      Multiply a field
$min/$max	  Set value only if lower/higher
$push/$pull	Add/remove from array
$push	      Add value to end of array
$each	      Push multiple values
$addToSet	  Add only if not already present
$pull	      Remove a value from array
$pullAll	  Remove multiple values
$set	      Replace value at a specific index



MongoDB stores data in BSON (Binary JSON)
format.

BSON includes all JSON datatypes and adds
more.

Choosing the correct datatype is essential
for efficient storage and querying.

In MongoDB, data types are important because they determine how data is stored, queried, and processed. Below is a detailed overview of the common MongoDB BSON data types, along with examples.


Common MongoDB Data Types (BSON)
Data Type	    Description	      Example
String	      Textual data	    "model": "Nexon"
NumberInt	32-bit integer	      "airbags": 2
NumberLong	64-bit integer	    NumberLong("9223372036854775807")
Double	     Floating point number	"mileage": 18.5
Boolean	      True or false	      "sunroof": true
Date	      Date and time	        new Date("2023-07-12")
ObjectId	Unique identifier auto-generated by MongoDB	"_id": ObjectId(...)
Array	List of values	"features": [ "ABS", "Bluetooth" ]
Object (Document)	Embedded document (key-value pairs)	"engine": { "cc": 1199, "type": "Turbo" }
Null	Represents a null or missing value	"color": null
Timestamp	Special timestamp for replication	Timestamp(12345678, 1)
Binary	Binary data (like images, files)	BinData(0, '...')
Regular Expression	-    For pattern matching	-    /^Nex/
MinKey / MaxKey-    Lowest / highest value for comparisons- MinKey(), MaxKey()


Example Document Using Various Types:
{
  _id: ObjectId("6872..."),
  model: "Nexon",                          // String
  airbags: 2,                              // NumberInt
  mileage: 17.5,                           // Double
  sunroof: false,                          // Boolean
  launch_date: new Date("2023-06-15"),     // Date
  features: [ "ABS", "Bluetooth" ],        // Array
  engine: { cc: 1199, type: "Turbo" },     // Object
  color: null                              // Null
}
https://www.mongodb.com/docs/manual/reference/bson-types/ 
Type Numbers (Internal BSON)
Type Name	Number
Double	1
String	2
Object	3
Array	4
Binary	5
Undefined	6
ObjectId	7
Boolean	8
Date	9
Null	10
Int32	16
Timestamp	17
Int64	18 

--------------------Operators------------
✅ 1. Comparison Operators
Operator	Meaning	Example
$eq	     Equal to	          { fuel_type: { $eq: "Petrol" } }
$ne	     Not equal	          { model: { $ne: "Creta" } }
$gt	     Greater than	     { "engine.cc": { $gt: 1500 } }
$gte	     Greater than or equal	{ airbags: { $gte: 4 } }
$lt	     Less than	          { airbags: { $lt: 6 } }
$lte	     Less than or equal	{ airbags: { $lte: 2 } }
$in	     Matches any value in array	{ model: { $in: [ "City", "Creta" ] } }
$nin	     Not in array	     { maker: { $nin: [ "Tata", "Honda" ] } }

✅ 2. Logical Operators
Operator	Meaning	Example
$and	     All conditions must be true	          { $and: [ { airbags: 6 }, { sunroof: true } ] }
$or	     Any condition can be true	          { $or: [ { maker: "Tata" }, { airbags: 2 } ] }
$not	     Negates a condition	                    { airbags: { $not: { $gt: 2 } } }
$nor      None of the conditions should be true	{ $nor: [ { maker: "Tata" }, { sunroof: true } ] }

✅ 3. Element Operators
Operator	Meaning	Example
$exists	     Checks if field exists	{ sunroof: { $exists: true } }
$type	     Checks field data type	{ sunroof: { $type: "bool" } }

✅ 4. Evaluation Operators
Operator	Meaning	Example
$expr	Use aggregation expressions in queries	{ $expr: { $gt: [ "$airbags", 4 ] } }
$regex	Matches string patterns (like LIKE)	{ model: { $regex: "^C" } }

✅ 5. Array Operators
Operator	Meaning	Example
$all-All elements must match	  { features: { $all: [ "Bluetooth", "ABS" ] } }
$elemMatch-Matches at least one element with all conditions	{ features: { $elemMatch: { $eq: "ABS" } } }
$size-Array length matches { features: { $size: 3 } }

$in	- Query	Matches if any value in array matches
$push	- Update	Adds an item to the array (can duplicate)
$addToSet	- Update	Adds to array only if not already present
$pull	- Update	Removes matching item(s) from an array
$pullAll	- Update	Removes multiple values from array
$pop	- Update	Removes first (-1) or last (1) item

✅ 6. Update Operators
Operator	Meaning	Example
$set	          Set or update a field	          { $set: { color: "Red" } }
$unset	        Remove a field	                { $unset:{ sunroof: "" } }
$inc	          Increment a numeric value	      { $inc: { airbags: 2 } }
$rename	     Rename a field	                    { $rename: { fuel_type: "fuelType" } }
$push	     Add to array	                    { $push: { features: "Voice Assist" } }
$pull	     Remove value from array	          { $pull: { features: "Sunroof" } }
$addToSet	     Add to array if not already present { $addToSet: { features: "ABS" } }
$pop	Remove first or last item in array
$min	Update only if new value is smaller
$max	Update only if new value is higher
$currentDate	Set current date/time
$pullAll	Remove multiple values from array

✅ 7. Aggregation Operators (used in pipelines)
Operator	Meaning	Example
$sum	      Sum values	     $sum: "$airbags"
$avg	      Average	          $avg: "$engine.cc"
$min	      Minimum	          $min: "$airbags"
$max	      Maximum	          $max: "$airbags"
$group	Group documents	{ _id: "$fuel_type", total: { $sum: 1 } }
$match	Filter documents	{ $match: { sunroof: true } }
$project	Include/exclude fields	{ $project: { model: 1, _id: 0 } }
------------------------

> Use $exists to:
    Filter incomplete data
    Find documents missing required fields
    Migrate/clean old schema

> Use $type to:
    Validate field format (string vs number)
    Avoid errors from bad data types
    Query specific value formats

-------Cursor Methods
When you use db.collection.find(), MongoDB returns a cursor object — not the actual documents immediately. You use cursor methods to control, filter, or process the output.

✅ What is a Cursor in MongoDB?
A cursor is a pointer to the result set of a query.

When you run find(), MongoDB creates a cursor to return documents one-by-one or in batches.

Most Useful Cursor Methods
Method	Description	Example
.forEach()	    Iterates over the cursor	            Print each doc
.toArray()	    Converts the cursor into an array	    Get all docs as array
.limit(n)	      Limits the number of results	        First n results
.skip(n)	      Skips the first n results	            Pagination
.sort()	        Sorts the results	                    Ascending/descending
.count()	 (Deprecated) Count documents in cursor	    Use .itcount() or countDocuments()
.pretty()	 Formats the output nicely in shell (Mongosh)	Better readability



# Aggregate Framework
Aggregation is a powerful framework for
Complex operations.

like filtering, grouping, sorting, reshaping, and
summarizing data in a flexible way via pipeline.

db.collection.aggregate(
       [
         {stage1}, 
         {stage2}...
       ], {option}
     )

Most commonly used stages in MongoDB aggregation:
$match
$group
$project
$sort
$limit
$unwind
$lookup
$addFields
$count
$skip

What is $group?
The $group stage groups input documents by a specified expression and lets you perform aggregations (like sum, avg, max, etc.) on grouped data.

>Syntax
{
  $group: {
    _id: <expression>,      // group by this field
    <field1>: { <accumulator1>: <expression> },
    <field2>: { <accumulator2>: <expression> },
    ...
  }
}

_id: The field to group by (required).
<field>: The new field name you’re creating (optional).
<accumulator>: What you want to calculate ($sum, $avg, etc.).

What is $match?
The $match stage filters documents in the pipeline, just like the find() method.
It uses query syntax to select documents that match the specified condition.

✅ Syntax
{
  $match: { <field>: <value> }
}

What is $count?
The $count stage is used to count the number of documents that pass through the pipeline.
It returns a single document with the count and a field name of your choice.

✅ Syntax
{ $count: "<field_name>" }
✅ The result will look like:
{ "<field_name>": <number> }


What is $project?
The $project stage is used to:

Include or exclude fields from documents

Rename fields

Create new fields

Transform data (e.g., convert, combine, extract parts)

Think of $project like the SELECT clause in SQL — it controls what your final output looks like.

✅ Syntax
{
  $project: {
    <field1>: 1 or 0,
    <field2>: 1 or 0,
    ...
    <newField>: <expression>
  }
}
1 means include the field

0 means exclude

You can also use computed expressions ($concat, $substr, $add, etc.)


What is $sort?
The $sort stage is used to sort documents in ascending or descending order based on one or more fields.

It’s used within aggregation pipelines and works similarly to .sort() in regular MongoDB queries.

✅ Syntax
{ 
  $sort: { 
    <field1>: 1 or -1, 
    <field2>: 1 or -1 
  } 
}
1 → Ascending order (small to big / A–Z)
-1 → Descending order (big to small / Z–A)


What is $limit?
The $limit stage restricts the number of documents that pass through the aggregation pipeline.

It works like SQL’s LIMIT or .limit() in MongoDB queries.

Syntax
{ $limit: <number> }
Replace <number> with how many documents you want to return.


✅ Returns only the first 5 documents from the collection.
Return only 5 cars

db.cars.aggregate([
  { $limit: 5 }
])


db.cars.aggregate([
  { $sort: { price: -1 } },  // High to low
  { $limit: 3 }
])
✅ Returns top 3 most expensive cars.


Get cheapest 2 electric cars

db.cars.aggregate([
  { $match: { fuel_type: "Electric" } },
  { $sort: { price: 1 } },   // Low to high
  { $limit: 2 }
])
✅ Filters electric cars, sorts them, and limits to 2 cheapest.

🔹 4. Use after $group
Example: Group by maker and show top 2 makers only:

db.cars.aggregate([
  { $group: { _id: "$maker", totalCars: { $sum: 1 } } },
  { $limit: 2 }
])


What is $limit?
The $limit stage restricts the number of documents that pass through the aggregation pipeline.
It works like SQL’s LIMIT or .limit() in MongoDB queries.

Syntax
{ $limit: <number> }
Replace <number> with how many documents you want to return.


What is $unwind?
The $unwind stage deconstructs an array field from each input document and creates a separate document for each element of the array.

It's used when you want to analyze or filter array items individually.

Syntax
{ $unwind: "$<arrayField>" }
Optional advanced syntax:
{
  $unwind: {
    path: "$<arrayField>",
    includeArrayIndex: "index",
    preserveNullAndEmptyArrays: true
  }
}


What is $lookup?
The $lookup stage is used to perform a left outer join between:
The current collection
And a foreign collection (another collection in the same database)
It combines related documents from different collections based on a matching field.


Syntax
{
  $lookup: {
    from: "<foreign_collection>",
    localField: "<field_in_current_collection>",
    foreignField: "<field_in_foreign_collection>",
    as: "<output_array_field>"
  }
}



What is $addFields?
The $addFields stage adds new fields to documents.
You can also modify existing fields.
It works just like $project, but it keeps all original fields unless you explicitly overwrite them.

Syntax
{
  $addFields: {
    <newField>: <value or expression>,
    ...
  }
}

Conditional Operators
$cond $ifNull $switch


1. $cond — IF / ELSE

✅ Syntax
{
  $cond: {
    if: <condition>,
    then: <value_if_true>,
    else: <value_if_false>
  }
}

Or shorthand syntax:
{ $cond: [ <condition>, <true>, <false> ] }

 2. $ifNull — Provide a default value
Used to return the first non-null value.

✅ Syntax
{ $ifNull: [ <expression>, <default_value> ] }


3. $switch — Multiple IF-ELSE Conditions
More readable when you have many if-else branches.

✅ Syntax
{
  $switch: {
    branches: [
      { case: <condition1>, then: <value1> },
      { case: <condition2>, then: <value2> },
      ...
    ],
    default: <default_value>
  }
}


Summary Table
Operator	Purpose	When to Use
$cond	Simple IF-THEN-ELSE	One condition
$ifNull	Fallback for null or missing	Provide default value
$switch	Multiple IF-THEN branches	More than two conditions

DATE Operators

$dateAdd   $dateDiff  $month  $year  $hour 

$dateOfMonth   $dayOfYear

1. $dateAdd — Add time to a date
✅ Syntax:
{
  $dateAdd: {
    startDate: <date>,
    unit: "<timeUnit>",
    amount: <number>
  }
}
| Time units: | "year", "month", "day", "hour", "minute", "second", etc.

2. $dateDiff — Difference between two dates
✅ Syntax:

{
  $dateDiff: {
    startDate: <date>,
    endDate: <date>,
    unit: "<timeUnit>"
  }
}

🔷 3. $month — Extract month number (1–12)
{ $month: "$orderDate" }
🔷 4. $year — Extract year
{ $year: "$orderDate" }
🔷 5. $hour — Extract hour (0–23)
{ $hour: "$orderDate" }
🔷 6. $dateOfMonth — Day of the month (1–31)
{ $dayOfMonth: "$orderDate" }
🔷 7. $dayOfYear — Day number in the year (1–366)
{ $dayOfYear: "$orderDate" }


Summary Table
Operator	        Description	Example
$dateAdd	        Add time units to a date	+7 days, +1 month
$dateDiff	        Find time difference between 2 dates	age, delivery gap
$month	          Extract month (1-12)	Jan = 1, Dec = 12
$year	            Extract year	2025
$hour	            Extract hour	0-23
$dayOfMonth	      Extract day in the month (1–31)	15
$dayOfYear	      Extract day in the year (1–366)	365

----------------
What Are Variables in MongoDB?
MongoDB provides two types of variables in aggregation:

System Variables — Predefined by MongoDB

User-Defined Variables — Created by you using $let or $setVariable

1. System Variables
Variable	        Description
$$ROOT	          The entire input document
$$CURRENT	        The current level document in pipeline stage
$$NOW	            The current timestamp (when the aggregation runs)
$$REMOVE	        Used to conditionally remove a field
$$DESCEND	        Controls traversal in $redact
$$CLUSTER_TIME	  Cluster timestamp

🔹 2. User-Defined Variables
You can define custom variables using:

$let — to declare local variables

$setVariable — to assign variable value dynamically

User Defined Variables

These variables allow you to store values and
reuse them within the same pipeline, making the
pipeline more readable and efficient in certain
scenarios

Data Modeling in MongoDB
Data modeling in MongoDB is the process of determining how data should be structured and related within a MongoDB collection. Unlike traditional relational databases that rely on normalized tables, MongoDB uses documents (in BSON format), allowing for flexible, nested data structures.

 Relationships in MongoDB
In MongoDB, relationships refer to how documents relate to one another across collections. Since MongoDB is a NoSQL, document-oriented database, relationships are implemented differently from SQL databases — using embedding or referencing instead of JOINs.


We can still model relationships between documents in
MongoDB using a few approaches. 
The two main types of relationships are:
Embedded Documents (Denormalization)
Referenced Documents (Normalization)


🔹 Types of Relationships in MongoDB
🔸 1. One-to-One (1:1)
Definition: One document is associated with one other document.

✅ Example – User and Profile (Embedded)
{
  "_id": 1,
  "name": "Nasim",
  "profile": {
    "bio": "Web Developer",
    "location": "Kolkata"
  }
}
✅ Example – User and Profile (Referenced)

// users
{ "_id": 1, "name": "Nasim", "profile_id": 101 }

// profiles
{ "_id": 101, "bio": "Web Developer", "location": "Kolkata" }
Use:

Embed if the profile is always accessed with the user.

Reference if it is large or accessed separately.

🔸 2. One-to-Many (1:N)
Definition: One document is related to multiple documents in another collection.

✅ Example – Customer and Orders (Referenced)

// customers
{ "_id": 1, "name": "Reja" }

// orders
[
  { "_id": 1001, "customer_id": 1, "product": "Car Tyre" },
  { "_id": 1002, "customer_id": 1, "product": "Engine Oil" }
]
✅ Example – Blog and Comments (Embedded)

{
  "_id": 1,
  "title": "MongoDB Relationships",
  "comments": [
    { "user": "Ali", "text": "Great post!" },
    { "user": "Mina", "text": "Very useful." }
  ]
}
Use:

Embed if the subdocuments are small and accessed together.

Reference for larger lists or independent access.

🔸 3. Many-to-Many (M:N)
Definition: Documents in one collection relate to many documents in another collection.

✅ Example – Students and Courses

// students
{ "_id": 1, "name": "Nasim", "course_ids": [101, 102] }

// courses
{ "_id": 101, "title": "MongoDB Basics" }
{ "_id": 102, "title": "React.js" }
You can also use a junction/association collection:

// student_courses
{ "student_id": 1, "course_id": 101 }
{ "student_id": 1, "course_id": 102 }
🔹 Implementing Relationships with $lookup
MongoDB provides the $lookup stage in aggregation for performing joins.

🔁 $lookup Example

db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer_info"
    }
  }
])

✅ Summary
Relationship Type	Example	Best Method
One-to-One	User ↔ Profile	Embed/Reference
One-to-Many	Blog ↔ Comments	Embed (small), Reference (large)
Many-to-Many	Student ↔ Courses	Reference + Lookup


JOIN with $lookup

db.users.aggregate([
    {
        "$lookup": {
            "from": "orders",       // The target collection to join with
            "localField": "_id",   // The field from the 'users' collection
            "foreignField": "user_id",   // The field from the 'orders' collection
            "as": "orders"  // The name of the new array field to add to the 'users' 
        }
    }
])


Schema Validation
MongoDB uses a JSON Schema format to define the
validation rules. 


Allows you to specify various constraints and rules
for your documents, such as required fields, field
types, and value ranges.


MongoDB is a schema-less NoSQL database, but it allows schema validation using JSON Schema (from MongoDB v3.6+). This helps you enforce rules on the structure of your documents — similar to schema in SQL.

🔹 Why Use Schema Validation?
✅ Ensure data consistency

✅ Prevent invalid or incomplete data

✅ Help teams understand document structure

✅ Easier debugging and development

 Enabling Schema Validation (Example)
Example: A collection for users with validation:

db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email", "age"],
      properties: {
        name: {
          bsonType: "string",
          description: "must be a string and is required"
        },
        email: {
          bsonType: "string",
          pattern: "^.+@.+$",
          description: "must be a valid email and is required"
        },
        age: {
          bsonType: "int",
          minimum: 18,
          description: "must be an integer >= 18 and is required"
        },
        phone: {
          bsonType: "string",
          description: "optional but must be a string"
        }
      }
    }
  },
  validationLevel: "strict",      // Options: off / moderate / strict
  validationAction: "error"       // Options: warn / error
})
📌 Options for Validation
Option	Description
validationLevel	"off", "moderate" (only new/updated fields), "strict" (all)
validationAction	"warn" (logs but allows insert), "error" (rejects invalid data)


Update Schema Validator on Existing Collection
db.runCommand({
  collMod: "users",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email"]
      // ...more rules
    }
  },
  validationLevel: "strict",
  validationAction: "error"
})



------------------
we can update the existing
collection to add validation

Update Existing Collection with Validation
Suppose you already have a collection called cars, and now you want to enforce some validation rules on it.

📌 Example
db.runCommand({
  collMod: "cars",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["model", "year", "price"],
      properties: {
        model: {
          bsonType: "string",
          description: "must be a string and is required"
        },
        year: {
          bsonType: "int",
          minimum: 2000,
          maximum: 2025,
          description: "must be an int between 2000 and 2025"
        },
        price: {
          bsonType: "double",
          minimum: 100000,
          description: "must be a double and at least 100000"
        },
        available: {
          bsonType: "bool",
          description: "optional availability status"
        }
      }
    }
  },
  validationLevel: "strict",    // (default: strict)
  validationAction: "error"     // (default: error)
})
🧠 Explanation
collMod: Used to modify an existing collection.

validator: The JSON Schema you want to apply.

validationLevel: "strict": Applies to all inserts/updates.

validationAction: "error": Rejects invalid documents.



What is an Index?
An index in MongoDB is similar to the index in a book — it helps locate data faster.

Without an index, MongoDB must scan every document in a collection to find the match (called collection scan). This is slow for large collections.


An INDEX is a data structure that improves
the speed of query operations by allowing
the database to quickly locate and access the
required data without scanning every
document in a collection.

Stores the indexed fields in a sorted order,
along with pointers to the actual documents
in the collection.

db.collection.createIndex(

    { <field1>: <type1>, 

        <field2>: <type2>, ... }, {<options> })


Why Use Indexes?
🔎 Faster Search (query optimization)
🧭 Efficient sorting
🚀 Speed up aggregation and lookup
✅ Ensure uniqueness of a field (like _id or email)


Types of Indexes
Type	                    Description
Single Field Index	      Index on one field (e.g., { name: 1 })
Compound Index	          Index on multiple fields (e.g., { name: 1, age: -1 })
Multikey Index	          Indexes array fields
Text Index	              Indexes string content for text search
Hashed Index	            Hash-based index for sharded collections
Wildcard Index	          Indexes dynamic or all fields (e.g., { "$**": 1 })
Geospatial Index	        For location-based queries (2d, 2dsphere)


Types of Indexes:
Single Field Index
Compound Index: Involves multiple fields.
Unique Index: Index that ensures no two documents have the
same value for the indexed field.
TTL Index: TTL (Time to Live) indexes that are used to
automatically remove documents after a certain period.


Create Index
// Single field index
db.users.createIndex({ email: 1 })

// Compound index
db.orders.createIndex({ customerId: 1, orderDate: -1 })

// Unique index
db.students.createIndex({ rollNo: 1 }, { unique: true })

// Text index
db.blogs.createIndex({ title: "text", content: "text" })


List Indexes
db.users.getIndexes()

Drop Index
// Drop by name
db.users.dropIndex("email_1")

// Drop all indexes
db.users.dropIndexes()




What is a Transaction?
A transaction in MongoDB is a set of operations (insert, update, delete, etc.) that are executed together.
They follow ACID properties:
Atomicity – All or nothing
Consistency – Data remains valid
Isolation – Transactions don’t interfere
Durability – Changes are permanent


When to Use Transactions?
Use transactions when:
You’re updating multiple documents/collections
You need strict consistency
You want to rollback if something fails



Replications
What is Replication?
Replication is the process of synchronizing data across multiple MongoDB servers (called nodes). It provides:

✅ High availability

✅ Data redundancy

✅ Automatic failover



🔷 What is ObjectId?
ObjectId is a 12-byte unique identifier that MongoDB automatically generates for each document unless you manually specify _id.

📦 ObjectId Structure (12 bytes = 96 bits):
Byte(s)	Content	Description
4	Timestamp	Time of creation (Unix epoch time)
5	Machine ID	Unique identifier of machine
2	Process ID	ID of MongoDB server process
3	Counter	Incrementing counter (ensures uniqueness)

Example:
const obj = ObjectId("64e45a8d1fcdb14723df5672");
console.log(obj.getTimestamp());  // Date derived from ObjectId



How to Create ObjectId

In MongoDB shell:
ObjectId()                 // generates a new ObjectId
ObjectId("...")            // parse existing ObjectId string

In Node.js (Mongoose/MongoDB driver):
const { ObjectId } = require('mongodb');
const id = new ObjectId();
console.log(id.toHexString());


ObjectId Methods
Method	                Description
ObjectId()	            Generates a new ObjectId
ObjectId.getTimestamp()	Gets the creation time as a Date object
ObjectId.toHexString()	Converts to 24-char hex string

Get Date from ObjectId:
const id = ObjectId("64e45a8d1fcdb14723df5672");
id.getTimestamp(); // → ISODate("2023-08-21T12:34:56Z")

🧠 Fun Fact:
If you sort by _id, you are essentially sorting by creation time because ObjectId starts with a timestamp.

🔐 Can I Use Custom _id?
Yes! You can assign any value (string, number, UUID) as _id:

db.users.insertOne({ _id: "nasim123", name: "Nasim Reja" });



❓ Is MongoDB Really Schemaless?
Short Answer:
MongoDB is not strictly schemaless, but it is schema-flexible.

✅ What Does “Schemaless” Mean?
Traditionally, relational databases (like MySQL) require:

Predefined tables

Strict columns and data types

MongoDB, in contrast:

Stores data in documents (BSON format)

Does not require a fixed structure across documents in a collection

👉 So you can insert documents with different shapes/fields.

🔍 Example: Flexible Schema
js
Copy
Edit
// First document
{
  name: "Nasim",
  age: 23,
  skills: ["React", "Node"]
}

// Second document
{
  name: "Reja",
  location: "Kolkata",
  isActive: true
}
✅ Both documents can exist in the same users collection without error.

⚠️ But Why It's Not Truly Schemaless?
MongoDB allows you to enforce schema validation using:

🔒 Schema Validation Rules
js
Copy
Edit
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email"],
      properties: {
        name: { bsonType: "string" },
        email: { bsonType: "string" },
        age: { bsonType: "int" }
      }
    }
  }
})
Now MongoDB rejects any document that doesn't match this schema.



 ordered Option in insert Command – MongoDB
In MongoDB, when you insert multiple documents using insertMany(), the ordered option determines how MongoDB handles errors during the operation.

🔹 Syntax:
js
Copy
Edit
db.collection.insertMany(
  [doc1, doc2, doc3, ...],
  { ordered: true | false }
)
✅ ordered: true (Default)
MongoDB inserts documents in order.

If one document fails (e.g., due to duplicate _id), it stops the operation and does not insert the remaining documents.

🔸 Example:
js
Copy
Edit
db.users.insertMany(
  [
    { _id: 1, name: "Nasim" },
    { _id: 2, name: "Reja" },
    { _id: 1, name: "DuplicateID" }, // Duplicate _id
    { _id: 3, name: "Mondal" }
  ],
  { ordered: true }
)
👉 Only documents with _id: 1 and _id: 2 will be inserted. The operation stops at the error.

✅ ordered: false
MongoDB inserts all valid documents, ignoring errors.

Errors are reported, but insertion continues for the rest.

🔸 Example:
js
Copy
Edit
db.users.insertMany(
  [
    { _id: 1, name: "Nasim" },
    { _id: 2, name: "Reja" },
    { _id: 1, name: "DuplicateID" },
    { _id: 3, name: "Mondal" }
  ],
  { ordered: false }
)
👉 _id: 1 and _id: 2 are inserted
👉 The duplicate _id is skipped
👉 _id: 3 is still inserted

✅ Use Cases:
Use Case	Use ordered
You want strict data integrity	true (default)
You want to insert as many as possible, even with some errors	false



Schema Validation in MongoDB
Although MongoDB is often called “schemaless,” schema validation allows you to enforce structure on documents in a collection using JSON Schema syntax.

🔹 Why Use Schema Validation?
Prevents invalid or inconsistent data.

Ensures required fields and value types.

Helps maintain data quality and integrity.

🔹 Enabling Validation on a Collection
You can apply validation rules while creating a collection or modifying an existing one.

✅ Create a Collection with Validation
js
Copy
Edit
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email", "age"],
      properties: {
        name: {
          bsonType: "string",
          description: "must be a string and is required"
        },
        email: {
          bsonType: "string",
          pattern: "^.+@.+$",
          description: "must be a valid email"
        },
        age: {
          bsonType: "int",
          minimum: 18,
          description: "must be an integer >= 18"
        }
      }
    }
  },
  validationLevel: "strict",   // or "moderate"
  validationAction: "error"    // or "warn"
})
✅ Update Validation on Existing Collection
js
Copy
Edit
db.runCommand({
  collMod: "users",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name"],
      properties: {
        name: {
          bsonType: "string"
        }
      }
    }
  },
  validationLevel: "strict",
  validationAction: "error"
})
🔹 Validation Levels
Level	Behavior
strict	Validates all inserts and updates (default).
moderate	Only validates new or updated fields; leaves existing ones alone.

🔹 Validation Actions
Action	Behavior
error	Rejects non-compliant documents.
warn	Logs the warning but allows the insert/update.

✅ Example Insert (Valid)
js
Copy
Edit
db.users.insertOne({
  name: "Nasim",
  email: "nasim@example.com",
  age: 25
})
❌ Example Insert (Invalid)
js
Copy
Edit
db.users.insertOne({
  name: "Nasim",
  email: "not-an-email",
  age: "twenty"
})
🛑 Will throw error if validationAction is "error".



✅ Write Concern in MongoDB
Write Concern in MongoDB determines how much acknowledgment you want from the database when performing a write operation like insert, update, or delete.

🔹 Why is Write Concern Important?
It affects:

Data durability

Fault tolerance

Performance

You choose how many replica set members must confirm the write before it is considered successful.

🔹 Write Concern Options
Value	Description
w: 0	No acknowledgment (fire-and-forget). Fastest, but unreliable.
w: 1	Acknowledged by primary only. Default setting.
w: "majority"	Acknowledged by majority of replica set members. Safe and reliable.
w: n	Acknowledged by n replica set members. Custom level.

🔹 Optional Settings
j: true → Wait for write to be written to the journal (ensures durability).

wtimeout: ms → Time in milliseconds to wait for write concern acknowledgment.

🔹 Examples
✅ Basic Write Concern (w: 1)
js
Copy
Edit
db.products.insertOne(
  { name: "Laptop", price: 55000 },
  { writeConcern: { w: 1 } }
)
✅ Majority Write Concern with Journal
js
Copy
Edit
db.orders.insertOne(
  { item: "Phone", qty: 2 },
  { writeConcern: { w: "majority", j: true, wtimeout: 5000 } }
)
🔹 Behavior in Replica Set
In a replica set, using "majority" ensures that the write is durable even if the primary node crashes immediately after the write.

🔸 Comparison Summary
Write Concern	Durability	Speed	Use Case
w: 0	❌ No	⚡ Fast	Logging, caching
w: 1	✅ Medium	⚡⚡ Good	Default usage
w: "majority"	✅✅ High	🐢 Slow	Financial, critical data
w: n	✅ Custom	Varies	Controlled environments



✅ MongoImport in MongoDB – Import JSON into MongoDB
mongoimport is a command-line tool used to import data into MongoDB collections from files like .json, .csv, or .tsv.

🔹 Basic Syntax (for JSON)
bash
Copy
Edit
mongoimport --db <database_name> --collection <collection_name> --file <path_to_json_file> --jsonArray
🔸 Example:
Suppose you have a file called cars.json:

json
Copy
Edit
[
  { "brand": "Toyota", "model": "Camry", "year": 2020 },
  { "brand": "Honda", "model": "Civic", "year": 2019 }
]
✅ Command:
bash
Copy
Edit
mongoimport --db car_dealership --collection inventory --file cars.json --jsonArray


🔹 Options Breakdown:
Option	Description
--db	Target database name (e.g., car_dealership)
--collection	Target collection name (e.g., inventory)
--file	Path to the JSON file
--jsonArray	Use this if your file contains a JSON array of documents
--drop	Drops (deletes) the collection before importing
--uri	Use if connecting to a remote MongoDB URI
--mode	insert (default), upsert, or merge

🔸 Import Single JSON Objects (Line-by-Line Format)
If your file looks like:

json
Copy
Edit
{ "name": "Nasim", "age": 23 }
{ "name": "Rahul", "age": 25 }
❌ Don’t use --jsonArray
✅ Use:

bash
Copy
Edit
mongoimport --db testDB --collection users --file users.json
🔹 Common Scenarios
✅ Drop collection and import new data

bash
Copy
Edit
mongoimport --db test --collection users --file users.json --drop --jsonArray
✅ Connect to remote MongoDB Atlas

bash
Copy
Edit
mongoimport --uri "mongodb+srv://username:password@cluster.mongodb.net/test" \
--collection users --file users.json --jsonArray
🔸 Verify Import
You can check imported data using Mongo shell:

js
Copy
Edit
use car_dealership
db.inventory.find().pretty()



✅ Understanding $exists and $type Operators in MongoDB
🔹 $exists Operator
Purpose:
Checks if a field exists (is present) or not in the document.

🔸 Syntax:
js
Copy
Edit
{ field: { $exists: <boolean> } }
true → Field exists (regardless of its value)

false → Field does not exist

🔸 Example:
Given this document:

json
Copy
Edit
{ "_id": 1, "name": "Nasim", "age": 25 }
✅ Find documents where "age" field exists:
js
Copy
Edit
db.users.find({ age: { $exists: true } })
❌ Find documents where "email" field does not exist:
js
Copy
Edit
db.users.find({ email: { $exists: false } })
🔹 $type Operator
Purpose:
Matches documents where the value of a field is of the specified BSON data type.

🔸 Syntax:
{ field: { $type: <type> } }
<type> can be a string (like "string", "number", "bool") or type number (2, 16, etc.)

🔸 Common BSON Data Types:
Type	Name	Type Number
"double"	64-bit float	1
"string"	String	2
"object"	Embedded Document	3
"array"	Array	4
"bool"	Boolean	8
"date"	Date	9
"null"	Null	10
"int"	32-bit int	16
"long"	64-bit int	18

🔸 Example:
Given:

{ "_id": 1, "name": "Nasim", "age": 25, "verified": true }
✅ Find documents where age is a number:

db.users.find({ age: { $type: "int" } })
✅ Find documents where verified is a boolean:

db.users.find({ verified: { $type: "bool" } })
✅ Match multiple types:

db.users.find({ age: { $type: ["int", "double"] } })
🔹 Combine $exists and $type:

db.users.find({
  email: { $exists: true, $type: "string" }
})
✅ This will return documents where the email field exists and its value is a string.



✅ Evaluation Operators in MongoDB
Evaluation operators in MongoDB allow you to evaluate documents based on certain conditions such as expressions, patterns (like regex), or script logic.

🔹 List of Common Evaluation Operators:
Operator	Description
$expr	Allows use of aggregation expressions in the query language.
$mod	Performs a modulo operation to match numeric values.
$regex	Matches strings using regular expressions.
$text	Performs text search on string content.
$where	Executes a JavaScript expression for custom matching logic.

🔸 1. $expr
✅ Allows querying using aggregation expressions.

Example: Match documents where price > discount:

db.products.find({
  $expr: { $gt: ["$price", "$discount"] }
})
🔸 2. $mod
✅ Matches documents where the value of a field modulo a divisor is a specific remainder.

Syntax:

{ field: { $mod: [divisor, remainder] } }
Example: Find users whose age is divisible by 5:

db.users.find({
  age: { $mod: [5, 0] }
})
🔸 3. $regex
✅ Performs pattern matching using regular expressions.

Example: Find users whose name starts with "Na":

db.users.find({
  name: { $regex: "^Na" }
})
You can also use $options for case-insensitive matching:

db.users.find({
  name: { $regex: "^na", $options: "i" }
})
🔸 4. $text
✅ Performs a text search on fields indexed with a text index.

Step 1: Create a text index:

db.articles.createIndex({ title: "text", content: "text" })
Step 2: Search using $text:

db.articles.find({
  $text: { $search: "mongodb index" }
})
🔸 Use "\"exact phrase\"" for exact matching, or - to exclude terms.

🔸 5. $where
✅ Allows use of JavaScript expressions to filter documents.

⚠️ Warning: Slower and not recommended for large-scale production queries.

Example: Find users whose age is greater than 25:

db.users.find({
  $where: "this.age > 25"
})
📌 Summary Table:
Operator	Use Case Example
$expr	Compare two fields
$mod	Match numbers divisible by a value
$regex	Pattern/text matching
$text	Full-text search
$where	Custom JavaScript condition



✅ Querying Arrays in MongoDB
MongoDB provides powerful operators to query arrays stored in documents. Arrays can be queried to match individual elements, elements with specific conditions, or even arrays of embedded documents.

🔹 Basic Example
json
Copy
Edit
{
  _id: 1,
  name: "Toyota",
  colors: ["red", "blue", "white"]
}
🔸 1. Match exact element in an array
Find documents where "colors" contains "red":

db.cars.find({ colors: "red" })
✅ This matches if at least one element is "red".

🔸 2. Match array with exact value/sequence
Find cars with colors exactly ["red", "blue"] in order:

db.cars.find({ colors: ["red", "blue"] })
⚠️ This matches only if the array exactly matches the order and number of elements.

🔸 3. $all — Match all specified values, in any order

db.cars.find({ colors: { $all: ["red", "white"] } })
✅ Returns documents that contain both "red" and "white" anywhere in the array.

🔸 4. $elemMatch — Match elements based on multiple conditions
Example Dataset:
json
Copy
Edit
{
  name: "Tesla",
  services: [
    { type: "repair", cost: 500 },
    { type: "paint", cost: 1000 }
  ]
}
Query: Find cars with a service of type "repair" and cost > 400:
js
Copy
Edit
db.cars.find({
  services: {
    $elemMatch: {
      type: "repair",
      cost: { $gt: 400 }
    }
  }
})
✅ $elemMatch is necessary when multiple conditions apply to the same array element.

🔸 5. Match array index values
Example: Find cars where second color (index 1) is "blue":
db.cars.find({
  "colors.1": "blue"
})
🔸 6. Query based on array length
MongoDB doesn’t have a direct $size query operator in match stage of aggregation, but you can use $size in find:

db.cars.find({
  colors: { $size: 3 }
})
✅ Finds documents where the colors array has exactly 3 elements.

📌 Summary of Operators
Operator	Description
field: value	Matches any element in array
$all	All values must be in the array
$elemMatch	Match elements with multiple conditions
field.index	Match value at specific index
$size	Match array of specific length




Effortlessly Sort Your MongoDB Documents: Tips & Tricks
Sorting in MongoDB is simple but powerful when used smartly. You can control the order of documents returned by your queries using the .sort() method — perfect for organizing data by name, date, price, etc.

🔸 1. Basic Sorting with .sort()
js
Copy
Edit
db.collection.find().sort({ field: 1 })   // Ascending
db.collection.find().sort({ field: -1 })  // Descending
✅ Example:

Sort users by name in ascending order:

db.users.find().sort({ name: 1 })
Sort users by age in descending order:

db.users.find().sort({ age: -1 })
🔸 2. Sort by Multiple Fields
You can sort by more than one field. MongoDB will sort by the first field, and use the second field to break ties.

db.users.find().sort({ age: 1, name: -1 })
➡️ Sorts by age ascending, and if ages are the same, then by name descending.

🔸 3. Sorting with Limit and Skip
Combine sorting with limit() and skip() for pagination:

db.products.find().sort({ price: -1 }).skip(10).limit(5)
✅ Fetch products sorted by highest price, skipping the top 10, and returning the next 5.

🔸 4. Sorting by Date
Assume documents like:

{ name: "Order1", createdAt: ISODate("2025-07-12T10:00:00Z") }
Sort newest to oldest:

db.orders.find().sort({ createdAt: -1 })
🔸 5. Sorting Embedded Fields
For nested documents:

{ name: "John", address: { city: "Delhi", pin: 110001 } }
Sort by city:

db.users.find().sort({ "address.city": 1 })
🔸 6. Indexing for Faster Sorting
If you sort frequently on a field, create an index:

db.users.createIndex({ age: 1 })
This boosts performance — especially for large collections.

🧠 Pro Tips
✅ Use .explain("executionStats") to see if sort uses index:

db.users.find().sort({ age: 1 }).explain("executionStats")
✅ Avoid sorting large result sets without indexes — it consumes memory and may hit SORT_MEMORY_LIMIT.

🛠 Summary
Task	                      Command Example
Ascending sort	            sort({ field: 1 })
Descending sort	            sort({ field: -1 })
Sort by multiple fields	    sort({ age: 1, name: -1 })
Combine with pagination	    sort(...).skip(...).limit(...)
Sort by nested field	      sort({ "address.city": 1 })
Improve with index	        createIndex({ field: 1 })



--------------------

# Advanced Update ( $inc, $min, $max, $mul, $unset, $rename & Upsert in MongoDB )

1. $inc (Increment a Value)
Increases a numeric field by a specified value.

db.users.updateOne(
  { name: "Nasim" },
  { $inc: { age: 1 } }
)
➡️ Increments the age field by 1.

🔧 2. $mul (Multiply a Value)
Multiplies the value of a field by a number.

db.products.updateOne(
  { name: "Laptop" },
  { $mul: { price: 1.1 } }
)
➡️ Increases price by 10%.

🔧 3. $min (Set Value If Lower)
Updates the field only if the new value is lower than the existing one.

db.students.updateOne(
  { name: "Ali" },
  { $min: { score: 85 } }
)
➡️ Only updates score if the current value is greater than 85.

🔧 4. $max (Set Value If Higher)
Updates the field only if the new value is greater than the existing one.

db.students.updateOne(
  { name: "Ali" },
  { $max: { score: 90 } }
)
➡️ Only updates score if the current value is less than 90.

🔧 5. $unset (Remove a Field)
Deletes a field from the document.

db.users.updateOne(
  { name: "Nasim" },
  { $unset: { address: "" } }
)
➡️ Removes the address field.

🔧 6. $rename (Rename a Field)
Renames a field.

db.users.updateOne(
  {},
  { $rename: { "dob": "birthDate" } }
)
➡️ Renames dob to birthDate.

⚡ 7. Upsert (Update or Insert if Not Exists)
If no document matches the filter, a new document is inserted with the given values.

db.users.updateOne(
  { name: "Rohit" },
  {
    $set: { age: 25, city: "Mumbai" }
  },
  { upsert: true }
)
➡️ If "Rohit" exists → update it.
➡️ If not → insert a new document with that data.

✅ Summary Table
Operator	Purpose	Example
$inc	Increment value	$inc: { age: 1 }
$mul	Multiply value	$mul: { price: 1.1 }
$min	Set value only if new is smaller	$min: { score: 85 }
$max	Set value only if new is higher	$max: { score: 90 }
$unset	Remove a field	$unset: { address: "" }
$rename	Rename a field	$rename: { "dob": "birthDate" }
upsert	Insert if no match found	{ upsert: true }



Updating Nested Arrays in MongoDB
To update elements inside an array of embedded documents, MongoDB provides dot notation and positional operator ($).

✅ Example Document
json
Copy
Edit
{
  _id: 1,
  name: "Nasim",
  subjects: [
    { name: "Math", score: 80 },
    { name: "English", score: 70 }
  ]
}
🛠️ Update the score of subject "Math":

db.students.updateOne(
  { name: "Nasim", "subjects.name": "Math" },
  { $set: { "subjects.$.score": 90 } }
)
🔍 $.score updates the first matched element in the subjects array.

📌 Array Operators
1. $push → Add Element to Array

db.users.updateOne(
  { name: "Nasim" },
  { $push: { hobbies: "reading" } }
)
➡️ Adds "reading" to the hobbies array.

2. $addToSet → Add Only If Not Exists (No Duplicates)

db.users.updateOne(
  { name: "Nasim" },
  { $addToSet: { hobbies: "cricket" } }
)
➡️ Adds "cricket" only if it's not already in the hobbies array.

3. $pull → Remove Matching Element(s)

db.users.updateOne(
  { name: "Nasim" },
  { $pull: { hobbies: "gaming" } }
)
➡️ Removes "gaming" from the hobbies array.

Can also remove objects:

db.students.updateOne(
  { name: "Nasim" },
  { $pull: { subjects: { name: "English" } } }
)
➡️ Removes the object with name: "English" from the subjects array.

4. $pop → Remove First or Last Element

db.users.updateOne(
  { name: "Nasim" },
  { $pop: { hobbies: -1 } }  // -1 = first, 1 = last
)
➡️ Removes the first item from hobbies.

🔁 Using $push with $each, $sort, $slice, and $position

db.users.updateOne(
  { name: "Nasim" },
  {
    $push: {
      hobbies: {
        $each: ["cycling", "painting"],
        $sort: 1,         // Sort alphabetically
        $slice: -3,       // Keep last 3 elements
        $position: 0      // Insert at beginning
      }
    }
  }
)
✅ Summary Table
Operator	            Action	          Example
$push	                Add element to array	$push: { arr: "item" }
$addToSet	Add only if not exists	$addToSet: { arr: "item" }
$pull	Remove element(s) matching value	$pull: { arr: "item" }
$pop	Remove first/last item	$pop: { arr: -1 or 1 }


// $bucket operator
The $bucket operator in MongoDB is used in the Aggregation Pipeline to group documents into buckets (ranges) based on a specified field’s value—much like a histogram.

🔍 Syntax
js
Copy
Edit
{
  $bucket: {
    groupBy: <expression>,     // Required. Field or expression to group by
    boundaries: [ <lower1>, <lower2>, ..., <upper> ],  // Required. Must be sorted.
    default: <bucket_label>,   // Optional. Label for values outside boundaries
    output: {                  // Optional. Output fields
      <field1>: { <accumulator>: <expression> },
      ...
    }
  }
}
📘 Example Dataset
js
Copy
Edit
db.students.insertMany([
  { name: "Nasim", marks: 45 },
  { name: "Riya", marks: 78 },
  { name: "Sam", marks: 89 },
  { name: "Asha", marks: 32 },
  { name: "Raj", marks: 92 },
  { name: "Tina", marks: 64 },
  { name: "Alex", marks: 55 }
])
📊 Example: Group Students by Marks
js
Copy
Edit
db.students.aggregate([
  {
    $bucket: {
      groupBy: "$marks",
      boundaries: [0, 50, 70, 100],  // [0-49], [50-69], [70-99]
      default: "Invalid Marks",
      output: {
        count: { $sum: 1 },
        students: { $push: "$name" }
      }
    }
  }
])
🧾 Output:
json
Copy
Edit
[
  {
    "_id": 0,
    "count": 2,
    "students": ["Nasim", "Asha"]
  },
  {
    "_id": 50,
    "count": 2,
    "students": ["Alex", "Tina"]
  },
  {
    "_id": 70,
    "count": 2,
    "students": ["Riya", "Sam"]
  },
  {
    "_id": "Invalid Marks",
    "count": 1,
    "students": ["Raj"]   // if Raj had marks > 100 or < 0
  }
]
✅ When to Use $bucket
Creating histograms of numerical data

Binning exam scores, age groups, prices, etc.

When range-based grouping is more useful than exact-match $group

🆚 Difference Between $bucket vs $bucketAuto
Feature	      $bucket	          $bucketAuto
Boundaries	  Manually defined	Automatically calculated
Flexibility	  More control	    Easier for unknown ranges
Output group  sizes	May vary	  Tries to keep bucket sizes similar


# $lookup in MongoDB – How to Perform Joins Between Collections

In MongoDB, joins between collections can be done using the $lookup stage in the Aggregation Pipeline. It’s MongoDB’s way of mimicking SQL-style joins.

📌 Syntax of $lookup

{
  $lookup: {
    from: "<foreign_collection>",
    localField: "<field_in_current_collection>",
    foreignField: "<field_in_foreign_collection>",
    as: "<output_array_field>"
  }
}
📘 Example Scenario
Let’s say we have two collections:

orders Collection:

[
  { _id: 1, customer_id: 101, total: 500 },
  { _id: 2, customer_id: 102, total: 300 }
]
customers Collection:

[
  { _id: 101, name: "Nasim", city: "Kolkata" },
  { _id: 102, name: "Riya", city: "Delhi" }
]
🔄 Join Using $lookup

db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer_info"
    }
  }
])
🧾 Output:

[
  {
    _id: 1,
    customer_id: 101,
    total: 500,
    customer_info: [
      {
        _id: 101,
        name: "Nasim",
        city: "Kolkata"
      }
    ]
  },
  {
    _id: 2,
    customer_id: 102,
    total: 300,
    customer_info: [
      {
        _id: 102,
        name: "Riya",
        city: "Delhi"
      }
    ]
  }
]
💡 Optional: Unwind the Joined Result
If you want to flatten the customer_info array into an object:

db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer_info"
    }
  },
  { $unwind: "$customer_info" }
])
✅ Benefits of $lookup
Performs left outer joins

Works within aggregation

Supports joins on embedded fields

Works for same-database collections

🛠 Advanced $lookup (with pipeline)
You can use $lookup with a pipeline (MongoDB 3.6+):

{
  $lookup: {
    from: "customers",
    let: { cust_id: "$customer_id" },
    pipeline: [
      { $match: { $expr: { $eq: ["$_id", "$$cust_id"] } } },
      { $project: { name: 1, city: 1 } }
    ],
    as: "customer_info"
  }
}
📌 Notes:
$lookup only works between collections in the same database.
Indexes on foreignField improve performance.
Result is an array, even if only one match is found (unless you unwind it).


📦 Capped Collection in MongoDB
A Capped Collection is a special type of fixed-size collection in MongoDB that maintains the insertion order and automatically overwrites the oldest documents when the specified size limit is reached.

✅ Key Features of Capped Collections
Feature	Description
🔒 Fixed Size	You specify a maximum size (in bytes) when creating it.
🔁 Circular	Oldest documents are overwritten when the cap is reached.
📥 Insert Order	Documents are stored in the order they are inserted.
⚡ Fast	High-performance for insert and read operations (like logs).
❌ No Delete/Update	Documents can't be removed or resized. Only inserts allowed.

📘 When to Use Capped Collections
Logging systems (like logs, events)

Real-time data (sensor readings, stock ticks)

Chat messages with size limit

🛠️ Create a Capped Collection
js
Copy
Edit
db.createCollection("logs", {
  capped: true,
  size: 10240,  // Size in bytes (10 KB here)
  max: 1000     // (Optional) Max number of documents
})
📤 Insert into a Capped Collection
js
Copy
Edit
db.logs.insertOne({ message: "System started", ts: new Date() })
📥 Read from a Capped Collection
js
Copy
Edit
db.logs.find()
🔄 Capped Collection Behavior
If the collection is full:

New documents are still inserted

Oldest documents are automatically deleted

⚠️ Limitations
You cannot remove or update size-changing fields in documents.

You cannot convert a normal collection to capped directly (but you can do a workaround).

Ideal only for append-only data.

🔁 Convert Normal to Capped (Workaround)
js
Copy
Edit
// Step 1: Copy existing data
db.normal.find().forEach(function(doc) {
  db.temp.insert(doc);
});

// Step 2: Drop old collection and create capped one
db.normal.drop();
db.createCollection("normal", { capped: true, size: 10000 });

// Step 3: Copy data back (only latest that fits will stay)
db.temp.find().forEach(function(doc) {
  db.normal.insert(doc);
});
📌 Summary
Capped collections are high-performance collections.

Great for use cases like logs, metrics, sensor data, etc.

They overwrite old data when full, so you never run out of space.

-----------
Mastering MongoDB: The Complete Guide to Authentication (RBAC)
MongoDB secures access to your data using authentication, authorization, and Role-Based Access Control (RBAC). This guide helps you understand and implement MongoDB's authentication and RBAC mechanisms effectively.

🧩 1. What Is Authentication in MongoDB?
Authentication is the process of verifying the identity of a client (user or application) trying to connect to the database.

MongoDB supports multiple authentication mechanisms:

SCRAM-SHA-1 / SCRAM-SHA-256 (default)

x.509 certificates

LDAP

Kerberos

🧷 2. Enabling Authentication
By default, MongoDB does not enable authentication. To enforce authentication:

🛠️ Edit the MongoDB Configuration File
yaml
Copy
Edit
# /etc/mongod.conf
security:
  authorization: "enabled"
Then restart MongoDB:

bash
Copy
Edit
sudo systemctl restart mongod
👑 3. What Is RBAC (Role-Based Access Control)?
RBAC lets you control what users can do and what resources they can access.

Users are assigned roles, and each role has a set of privileges (actions on resources).

🧱 4. MongoDB Built-in Roles
Role	Database	Description
read	Any	Read-only access
readWrite	Any	Read and write access
dbAdmin	Any	Schema-related operations
userAdmin	Any	Manage users and roles
clusterAdmin	admin	Cluster-wide administration
root	admin	Superuser (all permissions)

👤 5. Creating the First Admin User
You must create a user before enabling authentication.

🔸 Step 1: Start MongoDB without authentication:
bash
Copy
Edit
mongod --auth disabled
🔸 Step 2: Create an admin user:
js
Copy
Edit
use admin

db.createUser({
  user: "admin",
  pwd: "strongpassword",
  roles: [ { role: "root", db: "admin" } ]
})
🔸 Step 3: Restart MongoDB with authentication:
bash
Copy
Edit
mongod --auth
🔑 6. Creating Users with Specific Roles
✅ Example: Create a readWrite user on a specific DB
js
Copy
Edit
use yourDatabase

db.createUser({
  user: "nasim",
  pwd: "yourpassword",
  roles: [
    { role: "readWrite", db: "yourDatabase" }
  ]
})
🔐 7. Logging in with Authentication
bash
Copy
Edit
mongo -u "nasim" -p "yourpassword" --authenticationDatabase "yourDatabase"
🧩 8. Custom Roles in MongoDB
You can create custom roles with specific privileges.

🛠️ Example:
js
Copy
Edit
use yourDatabase

db.createRole({
  role: "customReader",
  privileges: [
    {
      resource: { db: "yourDatabase", collection: "orders" },
      actions: [ "find" ]
    }
  ],
  roles: []
})
Then assign it:

js
Copy
Edit
db.createUser({
  user: "customUser",
  pwd: "password123",
  roles: [ { role: "customReader", db: "yourDatabase" } ]
})
📋 9. Viewing Users and Roles
js
Copy
Edit
// View all users
use admin
db.getUsers()

// View roles
db.getRoles({ showPrivileges: true })
🧼 10. Deleting Users
js
Copy
Edit
db.dropUser("nasim")
🧠 Summary
Concept	Description
Authentication	Verifies identity of users/applications
RBAC	Assigns privileges based on roles
Built-in Roles	Predefined roles for common use-cases
Custom Roles	Fine-grained control over access
Enable Auth	Modify mongod.conf and restart


MongoDB Replication & Sharding Overview
MongoDB offers replication and sharding to provide high availability and horizontal scalability, respectively.

✅ Replication in MongoDB
Replication provides data redundancy and high availability using Replica Sets.

🔁 What is a Replica Set?
A replica set is a group of MongoDB servers that maintain the same data set. One member is primary, others are secondary.

📦 Key Components:
Primary: Handles all write operations.

Secondary: Replicates data from the primary.

Arbiter (optional): Participates in elections but doesn’t store data.

🔄 Automatic Failover:
If the primary goes down:

One of the secondaries is elected as the new primary.

Ensures high availability without manual intervention.

🔍 Replica Set Example:
javascript
Copy
Edit
rs.initiate({
  _id: "rs0",
  members: [
    { _id: 0, host: "localhost:27017" },
    { _id: 1, host: "localhost:27018" },
    { _id: 2, host: "localhost:27019" }
  ]
})
🔐 Benefits:
High Availability

Data Redundancy

Read scalability (via read preferences)

🔃 Sharding in MongoDB
Sharding is the process of distributing data across multiple servers (shards) to support horizontal scaling.

🔧 Components:
Shard: A MongoDB server that holds a subset of the sharded data.

Config Server: Stores metadata and cluster configuration.

Query Router (mongos): Routes client queries to the correct shard.

📊 How Sharding Works:
Data is partitioned using a shard key.

The shard key determines how the documents are distributed across shards.

MongoDB splits data into chunks and distributes them.

🔑 Example Shard Key:
bash
Copy
Edit
sh.enableSharding("car_dealership")
sh.shardCollection("car_dealership.cars", { model: 1 })
⚠️ Choosing a Good Shard Key:
Cardinality should be high.

Distribution should be even.

Query patterns should be considered.

🔄 Replication vs. Sharding
Feature	Replication	Sharding
Purpose	High availability	Horizontal scaling
Data	Copies of same data	Partitioned data
Components	Primary, Secondary, Arbiter	Shards, Config Server, Mongos
Use Case	Fault tolerance, backup	Large datasets, high load

Let me know if you want examples of replication setup, shard key design, or mongos configuration.


You said:
Transactions in MongoDB


ChatGPT said:
🔄 Transactions in MongoDB: A Complete Guide
MongoDB supports ACID-compliant transactions, allowing you to perform multiple operations across multiple documents and collections atomically, much like relational databases.

🧾 What is a Transaction?
A transaction is a sequence of operations that are:

Atomic: All or nothing.

Consistent: Data remains valid after transaction.

Isolated: Transactions do not affect each other.

Durable: Changes are saved permanently once committed.

✅ When to Use Transactions?
Use transactions when:

You need to update multiple documents in a single atomic operation.

You're working with multi-document updates across multiple collections.

You need strict consistency, such as banking, inventory, or order systems.

⚙️ Basic Syntax (Using MongoDB Shell or Node.js)
🔹 Start, Commit, Abort Example:
javascript
Copy
Edit
const session = db.getMongo().startSession();
session.startTransaction();

try {
  const usersCollection = session.getDatabase("shop").users;
  const ordersCollection = session.getDatabase("shop").orders;

  usersCollection.updateOne({ _id: 1 }, { $inc: { balance: -100 } });
  ordersCollection.insertOne({ userId: 1, item: "Laptop", amount: 100 });

  session.commitTransaction(); // ✅ Everything is saved
} catch (e) {
  session.abortTransaction();  // ❌ Everything is rolled back
} finally {
  session.endSession();
}
⚠️ Requirements and Limitations
Requirement	Description
MongoDB Version	Must be 4.0+ for replica sets, 4.2+ for sharded
Deployment	Must be in a replica set or sharded cluster
Write Concern	Should be "majority" for durability
Transaction Timeout	Default is 60 seconds
In-Memory Limit	~16MB of uncommitted changes

🧪 Multi-Document ACID Example (Node.js/Mongoose)
javascript
Copy
Edit
const session = await mongoose.startSession();
session.startTransaction();

try {
  await User.updateOne({ _id: userId }, { $inc: { balance: -50 } }, { session });
  await Order.create([{ userId, productId, amount: 50 }], { session });

  await session.commitTransaction();
} catch (error) {
  await session.abortTransaction();
}
session.endSession();
🆚 MongoDB Without Transactions
MongoDB operations are atomic on the document level. If you're working with a single document, you usually don’t need transactions.

💡 Best Practices
Keep transactions short-lived to avoid locking.

Use retry logic for transient errors.

Avoid using transactions if atomic single-document updates suffice (simpler & faster).

Always monitor performance using mongostat and mongotop.

> no sql
The NoSQL system or "Not Only SQL" is essentially a database that is made specifically for unstructured and semi-structured data in very large quantities. Unlike Conventional Relational Databases, where data are organized into tables using predefined schemas. NoSQL allows flexible models to be organized and horizontally scalable.

Why Use NoSQL?
Unlike relational databases, which use Structured Query Language, NoSQL databases do not have a universal query language. In fact, each NoSQL database has its own approach to query languages. Traditional relational databases will follow ACID principles, assuring a strong consistency and a structured relationship between the data.

Examples of NoSQL databases
Many companies have entered the NoSQL landscape. In addition to those mentioned above, here are some popular NoSQL databases:

Apache CouchDB, an open source, JSON document-based database that uses JavaScript as its query language.
Elasticsearch, a document-based database that includes a full-text search engine.
Couchbase, a key-value and document database that empowers developers to build responsive and flexible applications for cloud, mobile, and edge computing.

What is MongoDB?
MongoDB is an open source, nonrelational database management system (DBMS) that uses flexible documents instead of tables and rows to process and store various forms of data.

As a NoSQL database solution, MongoDB does not require a relational database management system (RDBMS), so it provides an elastic data storage model that enables users to store and query multivariate data types with ease. This not only simplifies database management for developers but also creates a highly scalable environment for cross-platform applications and services.

MongoDB documents or collections of documents are the basic units of data. Formatted as Binary JSON (Java Script Object Notation), these documents can store various types of data and be distributed across multiple systems. Since MongoDB employs a dynamic schema design, users have unparalleled flexibility when creating data records, querying document collections through MongoDB aggregation and analyzing large amounts of information.

> Basic Architecture of MongoDB
> Storage Format: BSON
> what is db / use <db>
> Schema
> what is collection / show collections / db.collection.find() / What is a Collection
>insertOne()
>insertMany()
>find()
>findOne()
>updateOne()
>updateMany()
>deleteOne()
>deleteMany()
>Operators
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>