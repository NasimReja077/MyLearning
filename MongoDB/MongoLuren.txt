https://www.canva.com/design/DAGNfeKTz_Q/nJB6OKFDJxFxiAxklMrVXw/edit
https://www.canva.com/design/DAGMvEWWNiA/45pt6qAw4b5LyswAqKLRPA/edit

Q1. What happens if you try insertMany([]) with an empty array?
Answer: It throws MongoInvalidArgumentError: Invalid BulkOperation, Batch cannot be empty because MongoDB requires at least one document.

Q2. What’s the correct command to view all documents from a collection named Teacher?
Answer: db.Teacher.find()

Q3. What will happen if you try db.Studnt.find() but only student collection exists?
Answer: It returns nothing (empty array) because there is no collection named Studnt.

Q4. Is show collections.Teacher a valid MongoDB command?
Answer: ❌ No. You should use show collections and then query using db.Teacher.find().

Q5. After switching to a database using use test, why doesn’t it show up in show dbs?
Answer: A database is not actually created until you insert at least one document in it.

# _id field - Automatically generated by MongoDB as the unique identifier for each document.
# Case Sensitivity - Collection names are case-sensitive: Teacher ≠ teacher.
# If you ever want to pretty-print the find() result: - test> db.Teacher.find().pretty()
# {} (empty filter)	Everything!	Dangerous — use with caution
Summary of Key Learnings:
Command	-Purpose	-Notes
db.collection.insertOne()    -  Insert a single document   -  Must provide a valid JSON object
db.collection.insertMany([]) - Insert multiple documents -   ❌ Fails if array is empty
show collections	     - Lists all collection names	-    ✅ No chaining allowed
db.collection.find()	- Shows documents from collection	 - Case-sensitive and typo-sensitive
use <db>	 -        Switches database	-    Doesn’t create it unless insert occurs


Basic Syntax
The find() method takes two optional arguments:

query (or filter): A document that specifies the selection criteria (which documents to return). If omitted or an empty document ({}), all documents in the collection are returned.

projection: A document that specifies which fields to include or exclude from the returned documents.

The general syntax is:

db.collection.find(query, projection)

MongoDB Update Operators Cheat Sheet:
Operator	  Meaning
$set	      Add new field or update value
$unset	    Remove field
$inc	      Increment numeric value
$rename	    Rename a field
$mul	      Multiply a field
$min/$max	  Set value only if lower/higher
$push/$pull	Add/remove from array
$push	      Add value to end of array
$each	      Push multiple values
$addToSet	  Add only if not already present
$pull	      Remove a value from array
$pullAll	  Remove multiple values
$set	      Replace value at a specific index



MongoDB stores data in BSON (Binary JSON)
format.

BSON includes all JSON datatypes and adds
more.

Choosing the correct datatype is essential
for efficient storage and querying.

In MongoDB, data types are important because they determine how data is stored, queried, and processed. Below is a detailed overview of the common MongoDB BSON data types, along with examples.


Common MongoDB Data Types (BSON)
Data Type	Description	Example
String	Textual data	"model": "Nexon"
NumberInt	32-bit integer	"airbags": 2
NumberLong	64-bit integer	NumberLong("9223372036854775807")
Double	Floating point number	"mileage": 18.5
Boolean	True or false	"sunroof": true
Date	Date and time	new Date("2023-07-12")
ObjectId	Unique identifier auto-generated by MongoDB	"_id": ObjectId(...)
Array	List of values	"features": [ "ABS", "Bluetooth" ]
Object (Document)	Embedded document (key-value pairs)	"engine": { "cc": 1199, "type": "Turbo" }
Null	Represents a null or missing value	"color": null
Timestamp	Special timestamp for replication	Timestamp(12345678, 1)
Binary	Binary data (like images, files)	BinData(0, '...')
Regular Expression	-    For pattern matching	-    /^Nex/
MinKey / MaxKey-    Lowest / highest value for comparisons- MinKey(), MaxKey()


Example Document Using Various Types:
{
  _id: ObjectId("6872..."),
  model: "Nexon",                          // String
  airbags: 2,                              // NumberInt
  mileage: 17.5,                           // Double
  sunroof: false,                          // Boolean
  launch_date: new Date("2023-06-15"),     // Date
  features: [ "ABS", "Bluetooth" ],        // Array
  engine: { cc: 1199, type: "Turbo" },     // Object
  color: null                              // Null
}
https://www.mongodb.com/docs/manual/reference/bson-types/ 
Type Numbers (Internal BSON)
Type Name	Number
Double	1
String	2
Object	3
Array	4
Binary	5
Undefined	6
ObjectId	7
Boolean	8
Date	9
Null	10
Int32	16
Timestamp	17
Int64	18 

--------------------Operators------------
✅ 1. Comparison Operators
Operator	Meaning	Example
$eq	     Equal to	          { fuel_type: { $eq: "Petrol" } }
$ne	     Not equal	          { model: { $ne: "Creta" } }
$gt	     Greater than	     { "engine.cc": { $gt: 1500 } }
$gte	     Greater than or equal	{ airbags: { $gte: 4 } }
$lt	     Less than	          { airbags: { $lt: 6 } }
$lte	     Less than or equal	{ airbags: { $lte: 2 } }
$in	     Matches any value in array	{ model: { $in: [ "City", "Creta" ] } }
$nin	     Not in array	     { maker: { $nin: [ "Tata", "Honda" ] } }

✅ 2. Logical Operators
Operator	Meaning	Example
$and	     All conditions must be true	          { $and: [ { airbags: 6 }, { sunroof: true } ] }
$or	     Any condition can be true	          { $or: [ { maker: "Tata" }, { airbags: 2 } ] }
$not	     Negates a condition	                    { airbags: { $not: { $gt: 2 } } }
$nor      None of the conditions should be true	{ $nor: [ { maker: "Tata" }, { sunroof: true } ] }

✅ 3. Element Operators
Operator	Meaning	Example
$exists	     Checks if field exists	{ sunroof: { $exists: true } }
$type	     Checks field data type	{ sunroof: { $type: "bool" } }

✅ 4. Evaluation Operators
Operator	Meaning	Example
$expr	Use aggregation expressions in queries	{ $expr: { $gt: [ "$airbags", 4 ] } }
$regex	Matches string patterns (like LIKE)	{ model: { $regex: "^C" } }

✅ 5. Array Operators
Operator	Meaning	Example
$all-All elements must match	  { features: { $all: [ "Bluetooth", "ABS" ] } }
$elemMatch-Matches at least one element with all conditions	{ features: { $elemMatch: { $eq: "ABS" } } }
$size-Array length matches { features: { $size: 3 } }

$in	- Query	Matches if any value in array matches
$push	- Update	Adds an item to the array (can duplicate)
$addToSet	- Update	Adds to array only if not already present
$pull	- Update	Removes matching item(s) from an array
$pullAll	- Update	Removes multiple values from array
$pop	- Update	Removes first (-1) or last (1) item

✅ 6. Update Operators
Operator	Meaning	Example
$set	          Set or update a field	          { $set: { color: "Red" } }
$unset	        Remove a field	                { $unset:{ sunroof: "" } }
$inc	          Increment a numeric value	      { $inc: { airbags: 2 } }
$rename	     Rename a field	                    { $rename: { fuel_type: "fuelType" } }
$push	     Add to array	                    { $push: { features: "Voice Assist" } }
$pull	     Remove value from array	          { $pull: { features: "Sunroof" } }
$addToSet	     Add to array if not already present { $addToSet: { features: "ABS" } }
$pop	Remove first or last item in array
$min	Update only if new value is smaller
$max	Update only if new value is higher
$currentDate	Set current date/time
$pullAll	Remove multiple values from array

✅ 7. Aggregation Operators (used in pipelines)
Operator	Meaning	Example
$sum	      Sum values	     $sum: "$airbags"
$avg	      Average	          $avg: "$engine.cc"
$min	      Minimum	          $min: "$airbags"
$max	      Maximum	          $max: "$airbags"
$group	Group documents	{ _id: "$fuel_type", total: { $sum: 1 } }
$match	Filter documents	{ $match: { sunroof: true } }
$project	Include/exclude fields	{ $project: { model: 1, _id: 0 } }
------------------------

> Use $exists to:
    Filter incomplete data
    Find documents missing required fields
    Migrate/clean old schema

> Use $type to:
    Validate field format (string vs number)
    Avoid errors from bad data types
    Query specific value formats

-------Cursor Methods
When you use db.collection.find(), MongoDB returns a cursor object — not the actual documents immediately. You use cursor methods to control, filter, or process the output.

✅ What is a Cursor in MongoDB?
A cursor is a pointer to the result set of a query.

When you run find(), MongoDB creates a cursor to return documents one-by-one or in batches.

Most Useful Cursor Methods
Method	Description	Example
.forEach()	    Iterates over the cursor	            Print each doc
.toArray()	    Converts the cursor into an array	    Get all docs as array
.limit(n)	      Limits the number of results	        First n results
.skip(n)	      Skips the first n results	            Pagination
.sort()	        Sorts the results	                    Ascending/descending
.count()	 (Deprecated) Count documents in cursor	    Use .itcount() or countDocuments()
.pretty()	 Formats the output nicely in shell (Mongosh)	Better readability



# Aggregate Framework
Aggregation is a powerful framework for
Complex operations.

like filtering, grouping, sorting, reshaping, and
summarizing data in a flexible way via pipeline.

db.collection.aggregate(
       [
         {stage1}, 
         {stage2}...
       ], {option}
     )

Most commonly used stages in MongoDB aggregation:
$match
$group
$project
$sort
$limit
$unwind
$lookup
$addFields
$count
$skip

What is $group?
The $group stage groups input documents by a specified expression and lets you perform aggregations (like sum, avg, max, etc.) on grouped data.

>Syntax
{
  $group: {
    _id: <expression>,      // group by this field
    <field1>: { <accumulator1>: <expression> },
    <field2>: { <accumulator2>: <expression> },
    ...
  }
}

_id: The field to group by (required).
<field>: The new field name you’re creating (optional).
<accumulator>: What you want to calculate ($sum, $avg, etc.).

What is $match?
The $match stage filters documents in the pipeline, just like the find() method.
It uses query syntax to select documents that match the specified condition.

✅ Syntax
{
  $match: { <field>: <value> }
}

What is $count?
The $count stage is used to count the number of documents that pass through the pipeline.
It returns a single document with the count and a field name of your choice.

✅ Syntax
{ $count: "<field_name>" }
✅ The result will look like:
{ "<field_name>": <number> }


What is $project?
The $project stage is used to:

Include or exclude fields from documents

Rename fields

Create new fields

Transform data (e.g., convert, combine, extract parts)

Think of $project like the SELECT clause in SQL — it controls what your final output looks like.

✅ Syntax
{
  $project: {
    <field1>: 1 or 0,
    <field2>: 1 or 0,
    ...
    <newField>: <expression>
  }
}
1 means include the field

0 means exclude

You can also use computed expressions ($concat, $substr, $add, etc.)


What is $sort?
The $sort stage is used to sort documents in ascending or descending order based on one or more fields.

It’s used within aggregation pipelines and works similarly to .sort() in regular MongoDB queries.

✅ Syntax
{ 
  $sort: { 
    <field1>: 1 or -1, 
    <field2>: 1 or -1 
  } 
}
1 → Ascending order (small to big / A–Z)
-1 → Descending order (big to small / Z–A)


What is $limit?
The $limit stage restricts the number of documents that pass through the aggregation pipeline.

It works like SQL’s LIMIT or .limit() in MongoDB queries.

Syntax
{ $limit: <number> }
Replace <number> with how many documents you want to return.


✅ Returns only the first 5 documents from the collection.
Return only 5 cars

db.cars.aggregate([
  { $limit: 5 }
])


db.cars.aggregate([
  { $sort: { price: -1 } },  // High to low
  { $limit: 3 }
])
✅ Returns top 3 most expensive cars.


Get cheapest 2 electric cars
js
Copy
Edit
db.cars.aggregate([
  { $match: { fuel_type: "Electric" } },
  { $sort: { price: 1 } },   // Low to high
  { $limit: 2 }
])
✅ Filters electric cars, sorts them, and limits to 2 cheapest.

🔹 4. Use after $group
Example: Group by maker and show top 2 makers only:

db.cars.aggregate([
  { $group: { _id: "$maker", totalCars: { $sum: 1 } } },
  { $limit: 2 }
])


What is $limit?
The $limit stage restricts the number of documents that pass through the aggregation pipeline.
It works like SQL’s LIMIT or .limit() in MongoDB queries.

Syntax
{ $limit: <number> }
Replace <number> with how many documents you want to return.


What is $unwind?
The $unwind stage deconstructs an array field from each input document and creates a separate document for each element of the array.

It's used when you want to analyze or filter array items individually.

Syntax
{ $unwind: "$<arrayField>" }
Optional advanced syntax:
{
  $unwind: {
    path: "$<arrayField>",
    includeArrayIndex: "index",
    preserveNullAndEmptyArrays: true
  }
}


What is $lookup?
The $lookup stage is used to perform a left outer join between:
The current collection
And a foreign collection (another collection in the same database)
It combines related documents from different collections based on a matching field.


Syntax
{
  $lookup: {
    from: "<foreign_collection>",
    localField: "<field_in_current_collection>",
    foreignField: "<field_in_foreign_collection>",
    as: "<output_array_field>"
  }
}



What is $addFields?
The $addFields stage adds new fields to documents.
You can also modify existing fields.
It works just like $project, but it keeps all original fields unless you explicitly overwrite them.

Syntax
{
  $addFields: {
    <newField>: <value or expression>,
    ...
  }
}



> no sql
>MongoDB
> Basic Architecture of MongoDB
> Storage Format: BSON
> what is db / use <db>
> Schema
> what is collection / show collections / db.collection.find() / What is a Collection
>insertOne()
>insertMany()
>find()
>findOne()
>updateOne()
>updateMany()
>deleteOne()
>deleteMany()
>Operators
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>