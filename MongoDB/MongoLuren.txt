https://www.canva.com/design/DAGNfeKTz_Q/nJB6OKFDJxFxiAxklMrVXw/edit
https://www.canva.com/design/DAGMvEWWNiA/45pt6qAw4b5LyswAqKLRPA/edit

Q1. What happens if you try insertMany([]) with an empty array?
Answer: It throws MongoInvalidArgumentError: Invalid BulkOperation, Batch cannot be empty because MongoDB requires at least one document.

Q2. What’s the correct command to view all documents from a collection named Teacher?
Answer: db.Teacher.find()

Q3. What will happen if you try db.Studnt.find() but only student collection exists?
Answer: It returns nothing (empty array) because there is no collection named Studnt.

Q4. Is show collections.Teacher a valid MongoDB command?
Answer: ❌ No. You should use show collections and then query using db.Teacher.find().

Q5. After switching to a database using use test, why doesn’t it show up in show dbs?
Answer: A database is not actually created until you insert at least one document in it.

# _id field - Automatically generated by MongoDB as the unique identifier for each document.
# Case Sensitivity - Collection names are case-sensitive: Teacher ≠ teacher.
# If you ever want to pretty-print the find() result: - test> db.Teacher.find().pretty()
# {} (empty filter)	Everything!	Dangerous — use with caution
Summary of Key Learnings:
Command	-Purpose	-Notes
db.collection.insertOne()    -  Insert a single document   -  Must provide a valid JSON object
db.collection.insertMany([]) - Insert multiple documents -   ❌ Fails if array is empty
show collections	     - Lists all collection names	-    ✅ No chaining allowed
db.collection.find()	- Shows documents from collection	 - Case-sensitive and typo-sensitive
use <db>	 -        Switches database	-    Doesn’t create it unless insert occurs


Basic Syntax
The find() method takes two optional arguments:

query (or filter): A document that specifies the selection criteria (which documents to return). If omitted or an empty document ({}), all documents in the collection are returned.

projection: A document that specifies which fields to include or exclude from the returned documents.

The general syntax is:

db.collection.find(query, projection)

MongoDB Update Operators Cheat Sheet:
Operator	  Meaning
$set	      Add new field or update value
$unset	    Remove field
$inc	      Increment numeric value
$rename	    Rename a field
$mul	      Multiply a field
$min/$max	  Set value only if lower/higher
$push/$pull	Add/remove from array
$push	      Add value to end of array
$each	      Push multiple values
$addToSet	  Add only if not already present
$pull	      Remove a value from array
$pullAll	  Remove multiple values
$set	      Replace value at a specific index



MongoDB stores data in BSON (Binary JSON)
format.

BSON includes all JSON datatypes and adds
more.

Choosing the correct datatype is essential
for efficient storage and querying.

In MongoDB, data types are important because they determine how data is stored, queried, and processed. Below is a detailed overview of the common MongoDB BSON data types, along with examples.


Common MongoDB Data Types (BSON)
Data Type	Description	Example
String	Textual data	"model": "Nexon"
NumberInt	32-bit integer	"airbags": 2
NumberLong	64-bit integer	NumberLong("9223372036854775807")
Double	Floating point number	"mileage": 18.5
Boolean	True or false	"sunroof": true
Date	Date and time	new Date("2023-07-12")
ObjectId	Unique identifier auto-generated by MongoDB	"_id": ObjectId(...)
Array	List of values	"features": [ "ABS", "Bluetooth" ]
Object (Document)	Embedded document (key-value pairs)	"engine": { "cc": 1199, "type": "Turbo" }
Null	Represents a null or missing value	"color": null
Timestamp	Special timestamp for replication	Timestamp(12345678, 1)
Binary	Binary data (like images, files)	BinData(0, '...')
Regular Expression	-    For pattern matching	-    /^Nex/
MinKey / MaxKey-    Lowest / highest value for comparisons- MinKey(), MaxKey()


Example Document Using Various Types:
{
  _id: ObjectId("6872..."),
  model: "Nexon",                          // String
  airbags: 2,                              // NumberInt
  mileage: 17.5,                           // Double
  sunroof: false,                          // Boolean
  launch_date: new Date("2023-06-15"),     // Date
  features: [ "ABS", "Bluetooth" ],        // Array
  engine: { cc: 1199, type: "Turbo" },     // Object
  color: null                              // Null
}
https://www.mongodb.com/docs/manual/reference/bson-types/ 
Type Numbers (Internal BSON)
Type Name	Number
Double	1
String	2
Object	3
Array	4
Binary	5
Undefined	6
ObjectId	7
Boolean	8
Date	9
Null	10
Int32	16
Timestamp	17
Int64	18 

--------------------Operators------------
✅ 1. Comparison Operators
Operator	Meaning	Example
$eq	     Equal to	          { fuel_type: { $eq: "Petrol" } }
$ne	     Not equal	          { model: { $ne: "Creta" } }
$gt	     Greater than	     { "engine.cc": { $gt: 1500 } }
$gte	     Greater than or equal	{ airbags: { $gte: 4 } }
$lt	     Less than	          { airbags: { $lt: 6 } }
$lte	     Less than or equal	{ airbags: { $lte: 2 } }
$in	     Matches any value in array	{ model: { $in: [ "City", "Creta" ] } }
$nin	     Not in array	     { maker: { $nin: [ "Tata", "Honda" ] } }

✅ 2. Logical Operators
Operator	Meaning	Example
$and	     All conditions must be true	          { $and: [ { airbags: 6 }, { sunroof: true } ] }
$or	     Any condition can be true	          { $or: [ { maker: "Tata" }, { airbags: 2 } ] }
$not	     Negates a condition	                    { airbags: { $not: { $gt: 2 } } }
$nor      None of the conditions should be true	{ $nor: [ { maker: "Tata" }, { sunroof: true } ] }

✅ 3. Element Operators
Operator	Meaning	Example
$exists	     Checks if field exists	{ sunroof: { $exists: true } }
$type	     Checks field data type	{ sunroof: { $type: "bool" } }

✅ 4. Evaluation Operators
Operator	Meaning	Example
$expr	Use aggregation expressions in queries	{ $expr: { $gt: [ "$airbags", 4 ] } }
$regex	Matches string patterns (like LIKE)	{ model: { $regex: "^C" } }

✅ 5. Array Operators
Operator	Meaning	Example
$all-All elements must match	  { features: { $all: [ "Bluetooth", "ABS" ] } }
$elemMatch-Matches at least one element with all conditions	{ features: { $elemMatch: { $eq: "ABS" } } }
$size-Array length matches { features: { $size: 3 } }

$in	- Query	Matches if any value in array matches
$push	- Update	Adds an item to the array (can duplicate)
$addToSet	- Update	Adds to array only if not already present
$pull	- Update	Removes matching item(s) from an array
$pullAll	- Update	Removes multiple values from array
$pop	- Update	Removes first (-1) or last (1) item

✅ 6. Update Operators
Operator	Meaning	Example
$set	          Set or update a field	          { $set: { color: "Red" } }
$unset	        Remove a field	                { $unset:{ sunroof: "" } }
$inc	          Increment a numeric value	      { $inc: { airbags: 2 } }
$rename	     Rename a field	                    { $rename: { fuel_type: "fuelType" } }
$push	     Add to array	                    { $push: { features: "Voice Assist" } }
$pull	     Remove value from array	          { $pull: { features: "Sunroof" } }
$addToSet	     Add to array if not already present { $addToSet: { features: "ABS" } }
$pop	Remove first or last item in array
$min	Update only if new value is smaller
$max	Update only if new value is higher
$currentDate	Set current date/time
$pullAll	Remove multiple values from array

✅ 7. Aggregation Operators (used in pipelines)
Operator	Meaning	Example
$sum	      Sum values	     $sum: "$airbags"
$avg	      Average	          $avg: "$engine.cc"
$min	      Minimum	          $min: "$airbags"
$max	      Maximum	          $max: "$airbags"
$group	Group documents	{ _id: "$fuel_type", total: { $sum: 1 } }
$match	Filter documents	{ $match: { sunroof: true } }
$project	Include/exclude fields	{ $project: { model: 1, _id: 0 } }
------------------------

> Use $exists to:
    Filter incomplete data
    Find documents missing required fields
    Migrate/clean old schema

> Use $type to:
    Validate field format (string vs number)
    Avoid errors from bad data types
    Query specific value formats

-------Cursor Methods
When you use db.collection.find(), MongoDB returns a cursor object — not the actual documents immediately. You use cursor methods to control, filter, or process the output.

✅ What is a Cursor in MongoDB?
A cursor is a pointer to the result set of a query.

When you run find(), MongoDB creates a cursor to return documents one-by-one or in batches.

Most Useful Cursor Methods
Method	Description	Example
.forEach()	    Iterates over the cursor	            Print each doc
.toArray()	    Converts the cursor into an array	    Get all docs as array
.limit(n)	      Limits the number of results	        First n results
.skip(n)	      Skips the first n results	            Pagination
.sort()	        Sorts the results	                    Ascending/descending
.count()	 (Deprecated) Count documents in cursor	    Use .itcount() or countDocuments()
.pretty()	 Formats the output nicely in shell (Mongosh)	Better readability



# Aggregate Framework
Aggregation is a powerful framework for
Complex operations.

like filtering, grouping, sorting, reshaping, and
summarizing data in a flexible way via pipeline.

db.collection.aggregate(
       [
         {stage1}, 
         {stage2}...
       ], {option}
     )

Most commonly used stages in MongoDB aggregation:
$match
$group
$project
$sort
$limit
$unwind
$lookup
$addFields
$count
$skip

What is $group?
The $group stage groups input documents by a specified expression and lets you perform aggregations (like sum, avg, max, etc.) on grouped data.

>Syntax
{
  $group: {
    _id: <expression>,      // group by this field
    <field1>: { <accumulator1>: <expression> },
    <field2>: { <accumulator2>: <expression> },
    ...
  }
}

_id: The field to group by (required).
<field>: The new field name you’re creating (optional).
<accumulator>: What you want to calculate ($sum, $avg, etc.).

What is $match?
The $match stage filters documents in the pipeline, just like the find() method.
It uses query syntax to select documents that match the specified condition.

✅ Syntax
{
  $match: { <field>: <value> }
}

What is $count?
The $count stage is used to count the number of documents that pass through the pipeline.
It returns a single document with the count and a field name of your choice.

✅ Syntax
{ $count: "<field_name>" }
✅ The result will look like:
{ "<field_name>": <number> }


What is $project?
The $project stage is used to:

Include or exclude fields from documents

Rename fields

Create new fields

Transform data (e.g., convert, combine, extract parts)

Think of $project like the SELECT clause in SQL — it controls what your final output looks like.

✅ Syntax
{
  $project: {
    <field1>: 1 or 0,
    <field2>: 1 or 0,
    ...
    <newField>: <expression>
  }
}
1 means include the field

0 means exclude

You can also use computed expressions ($concat, $substr, $add, etc.)


What is $sort?
The $sort stage is used to sort documents in ascending or descending order based on one or more fields.

It’s used within aggregation pipelines and works similarly to .sort() in regular MongoDB queries.

✅ Syntax
{ 
  $sort: { 
    <field1>: 1 or -1, 
    <field2>: 1 or -1 
  } 
}
1 → Ascending order (small to big / A–Z)
-1 → Descending order (big to small / Z–A)


What is $limit?
The $limit stage restricts the number of documents that pass through the aggregation pipeline.

It works like SQL’s LIMIT or .limit() in MongoDB queries.

Syntax
{ $limit: <number> }
Replace <number> with how many documents you want to return.


✅ Returns only the first 5 documents from the collection.
Return only 5 cars

db.cars.aggregate([
  { $limit: 5 }
])


db.cars.aggregate([
  { $sort: { price: -1 } },  // High to low
  { $limit: 3 }
])
✅ Returns top 3 most expensive cars.


Get cheapest 2 electric cars
js
Copy
Edit
db.cars.aggregate([
  { $match: { fuel_type: "Electric" } },
  { $sort: { price: 1 } },   // Low to high
  { $limit: 2 }
])
✅ Filters electric cars, sorts them, and limits to 2 cheapest.

🔹 4. Use after $group
Example: Group by maker and show top 2 makers only:

db.cars.aggregate([
  { $group: { _id: "$maker", totalCars: { $sum: 1 } } },
  { $limit: 2 }
])


What is $limit?
The $limit stage restricts the number of documents that pass through the aggregation pipeline.
It works like SQL’s LIMIT or .limit() in MongoDB queries.

Syntax
{ $limit: <number> }
Replace <number> with how many documents you want to return.


What is $unwind?
The $unwind stage deconstructs an array field from each input document and creates a separate document for each element of the array.

It's used when you want to analyze or filter array items individually.

Syntax
{ $unwind: "$<arrayField>" }
Optional advanced syntax:
{
  $unwind: {
    path: "$<arrayField>",
    includeArrayIndex: "index",
    preserveNullAndEmptyArrays: true
  }
}


What is $lookup?
The $lookup stage is used to perform a left outer join between:
The current collection
And a foreign collection (another collection in the same database)
It combines related documents from different collections based on a matching field.


Syntax
{
  $lookup: {
    from: "<foreign_collection>",
    localField: "<field_in_current_collection>",
    foreignField: "<field_in_foreign_collection>",
    as: "<output_array_field>"
  }
}



What is $addFields?
The $addFields stage adds new fields to documents.
You can also modify existing fields.
It works just like $project, but it keeps all original fields unless you explicitly overwrite them.

Syntax
{
  $addFields: {
    <newField>: <value or expression>,
    ...
  }
}

Conditional Operators
$cond $ifNull $switch


1. $cond — IF / ELSE

✅ Syntax
{
  $cond: {
    if: <condition>,
    then: <value_if_true>,
    else: <value_if_false>
  }
}

Or shorthand syntax:
{ $cond: [ <condition>, <true>, <false> ] }

 2. $ifNull — Provide a default value
Used to return the first non-null value.

✅ Syntax
{ $ifNull: [ <expression>, <default_value> ] }


3. $switch — Multiple IF-ELSE Conditions
More readable when you have many if-else branches.

✅ Syntax
{
  $switch: {
    branches: [
      { case: <condition1>, then: <value1> },
      { case: <condition2>, then: <value2> },
      ...
    ],
    default: <default_value>
  }
}


Summary Table
Operator	Purpose	When to Use
$cond	Simple IF-THEN-ELSE	One condition
$ifNull	Fallback for null or missing	Provide default value
$switch	Multiple IF-THEN branches	More than two conditions

DATE Operators

$dateAdd   $dateDiff  $month  $year  $hour 

$dateOfMonth   $dayOfYear

1. $dateAdd — Add time to a date
✅ Syntax:
{
  $dateAdd: {
    startDate: <date>,
    unit: "<timeUnit>",
    amount: <number>
  }
}
| Time units: | "year", "month", "day", "hour", "minute", "second", etc.

2. $dateDiff — Difference between two dates
✅ Syntax:
js
Copy
Edit
{
  $dateDiff: {
    startDate: <date>,
    endDate: <date>,
    unit: "<timeUnit>"
  }
}
🔷 3. $month — Extract month number (1–12)
js
Copy
Edit
{ $month: "$orderDate" }
🔷 4. $year — Extract year
js
Copy
Edit
{ $year: "$orderDate" }
🔷 5. $hour — Extract hour (0–23)
js
Copy
Edit
{ $hour: "$orderDate" }
🔷 6. $dateOfMonth — Day of the month (1–31)
js
Copy
Edit
{ $dayOfMonth: "$orderDate" }
🔷 7. $dayOfYear — Day number in the year (1–366)
js
Copy
Edit
{ $dayOfYear: "$orderDate" }
Summary Table
Operator	Description	Example
$dateAdd	Add time units to a date	+7 days, +1 month
$dateDiff	Find time difference between 2 dates	age, delivery gap
$month	Extract month (1-12)	Jan = 1, Dec = 12
$year	Extract year	2025
$hour	Extract hour	0-23
$dayOfMonth	Extract day in the month (1–31)	15
$dayOfYear	Extract day in the year (1–366)	365

----------------
What Are Variables in MongoDB?
MongoDB provides two types of variables in aggregation:

System Variables — Predefined by MongoDB

User-Defined Variables — Created by you using $let or $setVariable

1. System Variables
Variable	Description
$$ROOT	The entire input document
$$CURRENT	The current level document in pipeline stage
$$NOW	The current timestamp (when the aggregation runs)
$$REMOVE	Used to conditionally remove a field
$$DESCEND	Controls traversal in $redact
$$CLUSTER_TIME	Cluster timestamp

🔹 2. User-Defined Variables
You can define custom variables using:

$let — to declare local variables

$setVariable — to assign variable value dynamically

User Defined Variables

These variables allow you to store values and
reuse them within the same pipeline, making the
pipeline more readable and efficient in certain
scenarios

Data Modeling in MongoDB
Data modeling in MongoDB is the process of determining how data should be structured and related within a MongoDB collection. Unlike traditional relational databases that rely on normalized tables, MongoDB uses documents (in BSON format), allowing for flexible, nested data structures.

 Relationships in MongoDB
In MongoDB, relationships refer to how documents relate to one another across collections. Since MongoDB is a NoSQL, document-oriented database, relationships are implemented differently from SQL databases — using embedding or referencing instead of JOINs.


We can still model relationships between documents in
MongoDB using a few approaches. 
The two main types of relationships are:
Embedded Documents (Denormalization)
Referenced Documents (Normalization)


🔹 Types of Relationships in MongoDB
🔸 1. One-to-One (1:1)
Definition: One document is associated with one other document.

✅ Example – User and Profile (Embedded)
json
Copy
Edit
{
  "_id": 1,
  "name": "Nasim",
  "profile": {
    "bio": "Web Developer",
    "location": "Kolkata"
  }
}
✅ Example – User and Profile (Referenced)
json
Copy
Edit
// users
{ "_id": 1, "name": "Nasim", "profile_id": 101 }

// profiles
{ "_id": 101, "bio": "Web Developer", "location": "Kolkata" }
Use:

Embed if the profile is always accessed with the user.

Reference if it is large or accessed separately.

🔸 2. One-to-Many (1:N)
Definition: One document is related to multiple documents in another collection.

✅ Example – Customer and Orders (Referenced)
json
Copy
Edit
// customers
{ "_id": 1, "name": "Reja" }

// orders
[
  { "_id": 1001, "customer_id": 1, "product": "Car Tyre" },
  { "_id": 1002, "customer_id": 1, "product": "Engine Oil" }
]
✅ Example – Blog and Comments (Embedded)
json
Copy
Edit
{
  "_id": 1,
  "title": "MongoDB Relationships",
  "comments": [
    { "user": "Ali", "text": "Great post!" },
    { "user": "Mina", "text": "Very useful." }
  ]
}
Use:

Embed if the subdocuments are small and accessed together.

Reference for larger lists or independent access.

🔸 3. Many-to-Many (M:N)
Definition: Documents in one collection relate to many documents in another collection.

✅ Example – Students and Courses
json
Copy
Edit
// students
{ "_id": 1, "name": "Nasim", "course_ids": [101, 102] }

// courses
{ "_id": 101, "title": "MongoDB Basics" }
{ "_id": 102, "title": "React.js" }
You can also use a junction/association collection:

json
Copy
Edit
// student_courses
{ "student_id": 1, "course_id": 101 }
{ "student_id": 1, "course_id": 102 }
🔹 Implementing Relationships with $lookup
MongoDB provides the $lookup stage in aggregation for performing joins.

🔁 $lookup Example
js
Copy
Edit
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer_info"
    }
  }
])

✅ Summary
Relationship Type	Example	Best Method
One-to-One	User ↔ Profile	Embed/Reference
One-to-Many	Blog ↔ Comments	Embed (small), Reference (large)
Many-to-Many	Student ↔ Courses	Reference + Lookup


JOIN with $lookup

db.users.aggregate([
    {
        "$lookup": {
            "from": "orders",       // The target collection to join with
            "localField": "_id",   // The field from the 'users' collection
            "foreignField": "user_id",   // The field from the 'orders' collection
            "as": "orders"  // The name of the new array field to add to the 'users' 
        }
    }
])


Schema Validation
MongoDB uses a JSON Schema format to define the
validation rules. 


Allows you to specify various constraints and rules
for your documents, such as required fields, field
types, and value ranges.


MongoDB is a schema-less NoSQL database, but it allows schema validation using JSON Schema (from MongoDB v3.6+). This helps you enforce rules on the structure of your documents — similar to schema in SQL.

🔹 Why Use Schema Validation?
✅ Ensure data consistency

✅ Prevent invalid or incomplete data

✅ Help teams understand document structure

✅ Easier debugging and development

 Enabling Schema Validation (Example)
Example: A collection for users with validation:
js
Copy
Edit
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email", "age"],
      properties: {
        name: {
          bsonType: "string",
          description: "must be a string and is required"
        },
        email: {
          bsonType: "string",
          pattern: "^.+@.+$",
          description: "must be a valid email and is required"
        },
        age: {
          bsonType: "int",
          minimum: 18,
          description: "must be an integer >= 18 and is required"
        },
        phone: {
          bsonType: "string",
          description: "optional but must be a string"
        }
      }
    }
  },
  validationLevel: "strict",      // Options: off / moderate / strict
  validationAction: "error"       // Options: warn / error
})
📌 Options for Validation
Option	Description
validationLevel	"off", "moderate" (only new/updated fields), "strict" (all)
validationAction	"warn" (logs but allows insert), "error" (rejects invalid data)


Update Schema Validator on Existing Collection
js
Copy
Edit
db.runCommand({
  collMod: "users",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email"]
      // ...more rules
    }
  },
  validationLevel: "strict",
  validationAction: "error"
})



------------------
we can update the existing
collection to add validation

Update Existing Collection with Validation
Suppose you already have a collection called cars, and now you want to enforce some validation rules on it.

📌 Example
js
Copy
Edit
db.runCommand({
  collMod: "cars",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["model", "year", "price"],
      properties: {
        model: {
          bsonType: "string",
          description: "must be a string and is required"
        },
        year: {
          bsonType: "int",
          minimum: 2000,
          maximum: 2025,
          description: "must be an int between 2000 and 2025"
        },
        price: {
          bsonType: "double",
          minimum: 100000,
          description: "must be a double and at least 100000"
        },
        available: {
          bsonType: "bool",
          description: "optional availability status"
        }
      }
    }
  },
  validationLevel: "strict",    // (default: strict)
  validationAction: "error"     // (default: error)
})
🧠 Explanation
collMod: Used to modify an existing collection.

validator: The JSON Schema you want to apply.

validationLevel: "strict": Applies to all inserts/updates.

validationAction: "error": Rejects invalid documents.



What is an Index?
An index in MongoDB is similar to the index in a book — it helps locate data faster.

Without an index, MongoDB must scan every document in a collection to find the match (called collection scan). This is slow for large collections.


An INDEX is a data structure that improves
the speed of query operations by allowing
the database to quickly locate and access the
required data without scanning every
document in a collection.

Stores the indexed fields in a sorted order,
along with pointers to the actual documents
in the collection.

db.collection.createIndex(

    { <field1>: <type1>, 

        <field2>: <type2>, ... }, {<options> })


Why Use Indexes?
🔎 Faster Search (query optimization)
🧭 Efficient sorting
🚀 Speed up aggregation and lookup
✅ Ensure uniqueness of a field (like _id or email)


Types of Indexes
Type	                    Description
Single Field Index	      Index on one field (e.g., { name: 1 })
Compound Index	          Index on multiple fields (e.g., { name: 1, age: -1 })
Multikey Index	          Indexes array fields
Text Index	              Indexes string content for text search
Hashed Index	            Hash-based index for sharded collections
Wildcard Index	          Indexes dynamic or all fields (e.g., { "$**": 1 })
Geospatial Index	        For location-based queries (2d, 2dsphere)


Types of Indexes:
Single Field Index
Compound Index: Involves multiple fields.
Unique Index: Index that ensures no two documents have the
same value for the indexed field.
TTL Index: TTL (Time to Live) indexes that are used to
automatically remove documents after a certain period.


Create Index
// Single field index
db.users.createIndex({ email: 1 })

// Compound index
db.orders.createIndex({ customerId: 1, orderDate: -1 })

// Unique index
db.students.createIndex({ rollNo: 1 }, { unique: true })

// Text index
db.blogs.createIndex({ title: "text", content: "text" })


List Indexes
db.users.getIndexes()

Drop Index
// Drop by name
db.users.dropIndex("email_1")

// Drop all indexes
db.users.dropIndexes()




What is a Transaction?
A transaction in MongoDB is a set of operations (insert, update, delete, etc.) that are executed together.
They follow ACID properties:
Atomicity – All or nothing
Consistency – Data remains valid
Isolation – Transactions don’t interfere
Durability – Changes are permanent


When to Use Transactions?
Use transactions when:
You’re updating multiple documents/collections
You need strict consistency
You want to rollback if something fails



Replications
What is Replication?
Replication is the process of synchronizing data across multiple MongoDB servers (called nodes). It provides:

✅ High availability

✅ Data redundancy

✅ Automatic failover



🔷 What is ObjectId?
ObjectId is a 12-byte unique identifier that MongoDB automatically generates for each document unless you manually specify _id.

📦 ObjectId Structure (12 bytes = 96 bits):
Byte(s)	Content	Description
4	Timestamp	Time of creation (Unix epoch time)
5	Machine ID	Unique identifier of machine
2	Process ID	ID of MongoDB server process
3	Counter	Incrementing counter (ensures uniqueness)

Example:
const obj = ObjectId("64e45a8d1fcdb14723df5672");
console.log(obj.getTimestamp());  // Date derived from ObjectId



How to Create ObjectId

In MongoDB shell:
ObjectId()                 // generates a new ObjectId
ObjectId("...")            // parse existing ObjectId string

In Node.js (Mongoose/MongoDB driver):
const { ObjectId } = require('mongodb');
const id = new ObjectId();
console.log(id.toHexString());


ObjectId Methods
Method	                Description
ObjectId()	            Generates a new ObjectId
ObjectId.getTimestamp()	Gets the creation time as a Date object
ObjectId.toHexString()	Converts to 24-char hex string

Get Date from ObjectId:
const id = ObjectId("64e45a8d1fcdb14723df5672");
id.getTimestamp(); // → ISODate("2023-08-21T12:34:56Z")

🧠 Fun Fact:
If you sort by _id, you are essentially sorting by creation time because ObjectId starts with a timestamp.

🔐 Can I Use Custom _id?
Yes! You can assign any value (string, number, UUID) as _id:

db.users.insertOne({ _id: "nasim123", name: "Nasim Reja" });


> no sql
>MongoDB
> Basic Architecture of MongoDB
> Storage Format: BSON
> what is db / use <db>
> Schema
> what is collection / show collections / db.collection.find() / What is a Collection
>insertOne()
>insertMany()
>find()
>findOne()
>updateOne()
>updateMany()
>deleteOne()
>deleteMany()
>Operators
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>