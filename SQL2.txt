Q1. Create a new database
ans: CREATE DATABASE SCHOOL;

Q2. Display all databases
SHOW DATABASES;

Q3. Switch database.
USE school;

Q4. Drop a database
DROP DATABASE test;

Q5. Create a database, only if it does not already exist.
CREATE DATABASE IF NOT EXISTS test_1;

Q6. Drop the database ,only if it exists.
DROP DATABASE IF EXISTS test_1;

Q7. Drop multiple databases:
DROP DATABASE test_2, test_3;

Q8. Create a table
CREATE TABLE student (
    S_ID INT NOT NULL PRIMARY KEY,
    S_NAME VARCHAR(255) NOT NULL,
    S_AGE INT,
    S_CLASS INT,
    S_CITY VARCHAR(255),
    S_PHONE VARCHAR(20)
);

CREATE TABLE Teachers (
    T_ID INT NOT NULL PRIMARY KEY,
    T_NAME VARCHAR(255) NOT NULL,
    T_AGE INT,
    T_CITY VARCHAR(255),
    T_PHONE VARCHAR(20),
    T_SALARY DECIMAL(10, 2)
);

Q9. Show all tables in the current database.
SHOW TABLES;

Q10. Describe the structure of the student table.
DESC student;

Q11. Insert 6 records into the table.

INSERT INTO student (S_ID, S_NAME, S_AGE, S_CLASS, S_CITY, S_PHONE)
VALUES
    (1, 'Nasim', 20, 12, 'Kolkata', '1234567890'),
    (2, 'Reja', 18, 10, 'Kolkata', '1234567898'),
    (3, 'Joy', 19, 11, 'Kolkata', '9631237893'),
    (4, 'Alex', 20, 12, 'Hyderabad', '7891234560'),
    (5, 'Bob', 17, 9, 'Mumbai', '1237898520'),
    (6, 'Mew', 18, 11, 'Bengaluru', '1934667890');


INSERT INTO Teachers (T_ID, T_NAME, T_AGE, T_CITY, T_PHONE, T_SALARY)
VALUES
    (101, 'Alice Smith', 35, 'New York', '123-456-7890', 60000.00),
    (102, 'Bob Johnson', 42, 'Los Angeles', '987-654-3210', 75000.00),
    (103, 'Charlie Brown', 28, 'Chicago', '555-111-2222', 50000.00),
    (104, 'Diana Prince', 50, 'Houston', '777-888-9999', 85000.00),
    (105, 'Eve Adams', 30, 'Miami', '333-444-5555', 62000.00),
    (106, 'Frank White', 45, 'Seattle', '999-888-7777', 70000.00),
    (107, 'Grace Lee', 33, 'Dallas', '222-333-4444', 68000.00);


SHOW TABLES;

Q12. Display all records from the student & teachers table.
SELECT * FROM student;
SELECT * FROM teachers;

Q13. Describe the structure of the teachers table.
DESC teachers;


Create Sub-Tables (Derived Tables)
--
creat subtable 

Q14. Create a table KolkataStudents with students only from Kolkata.

CREATE TABLE KolkataStudents AS
SELECT * FROM student
WHERE S_CITY = "Kolkata";

Q15. Create a table SeniorClassStudents with class 12 or higher students, selecting specific columns.

CREATE TABLE SeniorClassStudents AS
SELECT S_ID, S_NAME, S_CLASS, S_PHONE FROM student
WHERE S_CLASS >=12;

Q16. Create a table C10StudentsContact with only class 10 students and their contact info.

CREATE TABLE C10StudentsContact AS
SELECT S_ID, S_NAME, S_PHONE FROM student
WHERE S_CLASS = 10;

Q17. Create a table HighSalaryTeachers with teachers earning ₹70,000 or more.

CREATE TABLE HighSalaryTeachers AS
SELECT T_ID, T_NAME, T_AGE, T_PHONE FROM teachers
WHERE T_SALARY >= 70000.00;

Q18. Create a table ExpertTeachers with teachers older than 40 years.

CREATE TABLE ExpertTeachers AS
SELECT T_ID, T_NAME, T_PHONE FROM teachers
WHERE T_AGE >40;

Q19. Show all tables in the database again to verify subtables.
SHOW TABLES;



Q20. Rename table student to StudentsTable.
ALTER TABLE student RENAME TO StudentsTable;

Q21. Rename column name to full_name in table CUSTOMERS.
ALTER TABLE CUSTOMERS RENAME COLUMN name to full_name;

ALTER TABLE studentstable CHANGE COLUMN S_NAME TO S_FULLNAME VARCHAR(255);

ALTER TABLE studentstable CHANGE COLUMN S_NAME  S_FULLNAME VARCHAR(255);

Q22. Add a new column DOB of type INT to students.
ALTER TABLE students ADD DOB INT;


Q23. Update DOB for S_ID = 1.
UPDATE students 
SET DOB = 20040516 
WHERE S_ID = 1;

Q24. Update DOB for multiple S_IDs using CASE statement.
UPDATE students
SET DOB = CASE S_ID
WHEN 2 THEN 20050901
WHEN 3 THEN 20060521
WHEN 4 THEN 20040911
WHEN 5 THEN 20051007
WHEN 6 THEN 20070307
END
WHERE S_ID IN (2,3,4,5,6);

Q25. Drop column Email from students.
ALTER TABLE students 
DROP COLUMN Email;


Q26.Modify datatype of a column (generic syntax).
LTER TABLE table_name
MODIFY COLUMN column_name datatype;

Q27.Drop table
DROP TABLE CUSTOMERS;

DROP TABLE IF EXISTS CUSTOMERS;

Q28. Display all rows from students.
SELECT * FROM students;

Q29. Delete a student where
DELETE FROM students WHERE S_FULLNAME = 'Reja';

DELETE * FROM GFG_Employees; 

Q30. Delete rows from CUSTOMERS where name is 'Komal' or address is 'Mumbai'.
DELETE FROM CUSTOMERS 
WHERE NAME='Komal' OR ADDRESS='Mumbai';

Q31.Truncate all data from CUSTOMERS table.
TRUNCATE TABLE CUSTOMERS;

-------------------
The SQL Clause

Q32. Retrieve all teachers whose age is less than or equal to 40.

SELECT * FROM teachers 
WHERE T_AGE <= 40;

Q33. Retrieve teacher details (ID, Name, Age, Phone) who are from Kolkata.

SELECT T_ID, T_NAME, T_AGE, T_PHONE 
FROM teachers 
WHERE T_CITY = 'KOLKATA';

Q34. Create a new table KolkataTeachers with data of teachers from Kolkata.

CREATE TABLE KolkataTeachers AS
SELECT T_ID, T_NAME, T_PHONE 
FROM teachers
WHERE T_CITY = "Kolkata";

Q35. Display all teachers who are not from New York.

SELECT * FROM Teachers 
WHERE NOT T_CITY = 'New York';

Q36. Retrieve teachers whose age is between 30 and 45 (inclusive).

SELECT * FROM teachers 
WHERE T_AGE BETWEEN 30 AND 45;

Q37. Retrieve teachers whose age is either 25 or 30.

SELECT * FROM teachers 
WHERE T_AGE IN (25,30);

Q38. Retrieve names of teachers starting with the letter 'B'.

SELECT T_NAME
FROM Teachers
WHERE T_NAME LIKE 'B%';

Q39. Retrieve name and city of teachers from either New York or Chicago.

SELECT T_NAME, T_CITY
FROM Teachers
WHERE T_CITY = 'New York' OR T_CITY = 'Chicago';

Q40. Update the salary to 53000 for all teachers in Chicago. 

UPDATE Teachers 
SET T_SALARY = 53000.00 
WHERE T_CITY = 'Chicago';

Q41. Update the name of the teacher to 'Nasim' where the city is Chicago.

UPDATE teachers 
SET T_NAME = 'Nasim' 
WHERE T_CITY = 'Chicago' ;

Q42. Delete all teachers whose age is less than or equal to 25.

DELETE FROM teachers 
WHERE T_AGE <= 25;


// The SQL ORDER BY Clause

Q43. Display all teachers sorted in ascending order by their name.

SELECT * FROM teachers ORDER BY T_NAME ASC;

Q44. Display all teachers sorted in descending order by their name.

SELECT * FROM teachers ORDER BY T_NAME DESC;

Q45. Display teachers ordered by ascending age and descending salary.

SELECT * FROM teachers 
ORDER BY T_AGE ASC, T_SALARY DESC;

Q46. Display teachers with age ≤ 45, ordered by name in descending order.

SELECT * FROM teachers 
WHERE T_AGE <=45 
ORDER BY T_NAME DESC;

Q47. Retrieve top 3 teachers’ IDs, names, and salaries sorted by name.

SELECT T_ID,T_NAME,T_SALARY 
FROM teachers 
ORDER BY T_NAME LIMIT 3;

Q48. Retrieve teachers from New York ordered by age in ascending order.

SELECT T_NAME, T_AGE, T_CITY
FROM Teachers
WHERE T_CITY = 'New York'
ORDER BY T_AGE ASC;

Q49. Show average salary per city, sorted by salary descending.

SELECT T_CITY, AVG(T_SALARY) AS AverageSalary
FROM Teachers
GROUP BY T_CITY
ORDER BY AverageSalary DESC;


Q50. Retrieve the top 3 oldest teachers with their names and ages.

SELECT T_NAME, T_AGE
FROM Teachers
ORDER BY T_AGE DESC
LIMIT 3;

Q51. Retrieve 3 teachers starting from the 3rd alphabetically.

SELECT T_ID, T_NAME
FROM Teachers
ORDER BY T_NAME ASC
LIMIT 2, 3;

 OFFSET 2 means skip first 2 rows, then take next 3.

----------------------
Pattern	Meaning
'a%'	Match strings that start with 'a'

'%a'	Match strings with end with 'a'

'a%t'	Match strings that contain the start with 'a' and end with 't'.

'%wow%'	Match strings that contain the substring 'wow' in them at any position.

'_wow%'	Match strings that contain the substring 'wow' in them at the second position.

'_a%'	Match strings that contain 'a' at the second position.

'a_ _%'	Match strings that start with 'a and contain at least 2 more characters.

-------------------
UNION

Q56. Combine name and city from teachers and students using UNION.

SELECT T_NAME AS Name, T_CITY AS City
FROM teachers
UNION
SELECT S_FULLNAME AS Name, S_CITY AS City
FROM students;

Q57. Same as above but include duplicates using UNION ALL.

SELECT T_NAME AS NAME, T_CITY AS CITY
FROM teachers
UNION ALL 
SELECT S_FULLNAME AS NAME, S_CITY AS CITY
FROM students;

Q58. Get contact names and phone numbers of all people in Kolkata.

SELECT T_NAME AS CONTACTNAME, T_PHONE AS PHONENUMBER
FROM teachers
WHERE T_CITY = 'Kolkata'
UNION ALL
SELECT S_FULLNAME AS CONTACTNAME, S_PHONE AS PHONENUMBER
FROM students
WHERE S_CITY = 'Kolkata';

Q59. Retrieve all distinct cities from both teachers and students.

SELECT T_CITY FROM teachers
UNION
SELECT S_CITY FROM students
ORDER BY CITY;
OR--
SELECT T_CITY AS City FROM teachers
UNION
SELECT S_CITY AS City FROM students
ORDER BY City;


-----------
SQL Aggregate functions

Q60. Count the total number of teachers.

SELECT COUNT(*) AS TOTAL_TEACHERS
FROM teachers;

Q61. Count how many teachers have a non-null age.

SELECT COUNT(T_AGE) AS TEACHERS_AGE
FROM Teachers;

Q62. Count how many students are from Kolkata.

SELECT COUNT(*) AS KOLKATA_STUDENTS 
FROM students 
WHERE S_CITY = 'Kolkata';

Q63. Count the number of teachers in each city.

SELECT T_CITY, COUNT(T_ID) AS NUMBER_OF_TEACHERS_IN_CITY
FROM teachers
GROUP BY T_CITY;

Q64. Count the number of students in each class.

SELECT S_CLASS, COUNT(S_ID) AS NUMBER_OF_STUDENT_IN_CLASS
FROM students
GROUP BY S_CLASS;


Q65. Show cities that have more than one teacher.

SELECT T_CITY, COUNT(T_ID) AS NUMBEROFTEACHERS
FROM teachers
GROUP BY T_CITY
HAVING COUNT(T_ID) > 1;

Q66. Show the average salary of all teachers.

SELECT AVG(T_SALARY) AS AverageTeacherSalary
FROM Teachers;


Q66. Show the average salary of all teachers.

SELECT AVG(T_SALARY) AS AverageSalaryNewYork
FROM Teachers
WHERE T_CITY = 'New York';

Q68. Show the average salary per city.

SELECT T_CITY, AVG(T_SALARY) AS AverageSalaryPerCity
FROM Teachers
GROUP BY T_CITY;


Q69. Show the total salary paid to all teachers.

SELECT SUM(T_SALARY) AS TOTAL_SALARY
FROM teachers;

Q70. Show total salary of teachers in Kolkata.

SELECT SUM(T_SALARY) AS KolkataTeachersTotalSalary
FROM Teachers
WHERE T_CITY = 'Kolkata';

Q71. Find the lowest salary among all teachers.

SELECT MIN(T_SALARY) AS LowestTeacherSalary
FROM Teachers;

Q72. Find the youngest student’s age.

SELECT MIN(S_AGE) AS YoungestStudentAge
FROM studentstable;

Q73. Find the minimum salary per city.

SELECT T_CITY, MIN(T_SALARY) AS MinSalaryPerCity
FROM Teachers
GROUP BY T_CITY;

Q74. Find the minimum student age per class.

SELECT S_CLASS, MIN(S_AGE) AS MinAgePerClass
FROM studentstable
GROUP BY S_CLASS;

Q75. Find the highest salary among teachers.

SELECT MAX(T_SALARY) AS HighestTeacherSalary
FROM Teachers;

Q76. Find the oldest student’s age.

SELECT MAX(S_AGE) AS OldestStudentAge
FROM studentstable;

Q77. Find the maximum teacher salary per city.

SELECT T_CITY, MAX(T_SALARY) AS MaxSalaryPerCity
FROM Teachers
GROUP BY T_CITY;

---------------

Q78. Find number of teachers per city.

SELECT T_CITY, COUNT(T_ID) AS NB_OF_TEACHERS
FROM teachers 
GROUP BY T_CITY;

Q79. Show average salary of teachers grouped by city.

SELECT T_CITY, AVG(T_SALARY) AS AVARAGE_SALARY
FROM teachers
GROUP BY T_CITY;

Q80. Show the oldest and youngest teacher per city.

SELECT T_CITY, MAX(T_AGE) AS MAX_AGE_TEACHERS, MIN(T_AGE) AS MIN_AGE_TEACHERS
FROM teachers
GROUP BY T_CITY;

Q81. Show number of teachers with salary ≥ 60000 grouped by city.

SELECT T_CITY, T_NAME, COUNT(T_ID) AS NUMBER_TEACHERS_SAL
FROM teachers
WHERE T_SALARY >= 60000.00
GROUP BY T_CITY;

Q82. Show student count grouped by age.

SELECT S_AGE, COUNT(S_FULLNAME) AS NUMBEROF_STUDENT 
FROM students
GROUP BY S_AGE;

Q82. Show student count grouped by age.

SELECT S_AGE, COUNT(S_FULLNAME) AS NUMBEROF_STUDENT 
FROM students
GROUP BY S_AGE;

Q83. Show student count by age, but only for age ≥ 18.

SELECT S_AGE, COUNT(S_FULLNAME) AS NUMBEROF_STUDENT 
FROM students
WHERE S_AGE >= 18
GROUP BY S_AGE;
--------

Q84. Show cities with average teacher salary > ₹65000.

SELECT T_CITY, AVG(T_SALARY) AS AVG_SALARY
FROM teachers
GROUP BY T_CITY
HAVING AVG (T_SALARY) > 65000.00;

-- Explanation:
-- 1. GROUP BY T_CITY: Groups teachers by their city.
-- 2. AVG(T_SALARY): Calculates the average salary for each city group.
-- 3. HAVING AVG(T_SALARY) > 65000.00: Filters these groups, keeping only those where the calculated average salary is greater than 65000.00.

Q85. Show student cities where more than 1 student lives.

SELECT S_CITY, COUNT(S_ID) AS NUMBER_OF_STUDENTS
FROM students
GROUP BY S_CITY
HAVING COUNT(S_ID) > 1;

-- Explanation:
-- 1. GROUP BY T_CITY: Groups teachers by city.
-- 2. COUNT(T_ID): Counts the number of teachers in each city group.
-- 3. HAVING COUNT(T_ID) > 1: Filters these groups, keeping only cities with more than 1 teacher.

Q86. Show cities where the youngest teacher is under 30.

SELECT T_CITY, MIN(T_AGE) AS NIMAGE_TEACHERS
FROM teachers
GROUP BY T_CITY
HAVING MIN(T_AGE) < 30;


SELECT T_CITY, SUM(T_SALARY) AS TOTAL_SAL
FROM teachers 
GROUP BY T_CITY
HAVING SUM(T_SALARY);

Q87. Show cities where total salary of teachers is between ₹120000 and ₹150000.

SELECT T_CITY, SUM(T_SALARY) AS TOTAL_SAL
FROM teachers 
GROUP BY T_CITY
HAVING SUM(T_SALARY) BETWEEN 120000.00 AND 150000.00;

Q88. Show cities with exactly 2 teachers and salary sum > ₹60000.

SELECT T_CITY, AVG(T_SALARY) AS AVG_SALARY, COUNT(T_ID) AS NB_TEACHERS
FROM teachers
GROUP BY T_CITY
HAVING SUM(T_SALARY) > 60000.00 AND COUNT(T_ID) = 2;

Q89. Show total salary per city in descending order.

SELECT T_CITY, SUM(T_SALARY) AS TOTAL_SAL
FROM teachers 
GROUP BY T_CITY
HAVING SUM(T_SALARY)
ORDER BY TOTAL_SAL DESC;


Q90. Show teacher name, age, city and total salary grouped by city and age where salary ≥ ₹65000.

SELECT T_NAME, T_AGE, T_CITY, SUM(T_SALARY) AS TOTAL_SAL
FROM teachers
GROUP BY T_CITY,
T_AGE HAVING TOTAL_SAL >=65000.00
ORDER BY TOTAL_SAL ASC;
--------------
SQL WITH Clause Examples BAKE 
-------------------------

sql queries

Q91. Update the city of the teacher with T_ID = 103 to 'Bostan'.

UPDATE teachers
SET T_CITY = 'Bostan'
WHERE T_ID = 103;

Q92. Increase the salary of all teachers in Kolkata by 10%.

UPDATE teachers
SET T_SALARY = T_SALARY * 1.10
WHERE T_CITY = 'Kolkata';

Q94. Delete all employees from GFG_Employees in the 'Development' department.

DELETE * FROM GFG_Employees; 


DELETE FROM GFG_Employees 
WHERE department = 'Development';

Q95. Select top 5 highest paid teachers.

SELECT TOP 5 T_NAME, T_SALARY
FROM teachers
ORDER BY T_SALARY DESC;

TOP is used in SQL Server, while LIMIT is used in MySQL.

Q96. Select first 3 rows alphabetically using FETCH (standard SQL).

SELECT T_ID, T_NAME
-- FROM Teachers
-- ORDER BY T_NAME ASC
-- FETCH FIRST 3 ROWS ONLY;

 Standard SQL syntax; might not work in MySQL — use LIMIT 3 for MySQL.

Q97. Skip 2 rows and fetch next 2 rows (pagination-like behavior).

SELECT T_ID, T_NAME
-- FROM Teachers
-- ORDER BY T_NAME ASC
-- OFFSET 2 ROWS
-- FETCH NEXT 2 ROWS ONLY;

 CONCEPTUAL: Get the top 2 teachers by salary, including ties (SQL Standard syntax)
-- SELECT T_NAME, T_SALARY
-- FROM Teachers
-- ORDER BY T_SALARY DESC
-- FETCH FIRST 2 ROWS WITH TIES;

------------
Q99. Select students in class 10 or 12.

SELECT S_FULLNAME, S_CLASS
FROM students
WHERE S_CLASS IN (10, 12);

Q100. Select teachers not in New York or Chicago.

SELECT T_NAME, T_CITY
FROM teachers
WHERE T_CITY NOT IN ('New York', 'Chicago');

Q101. Select teachers whose city exists in the students table.

SELECT T_NAME, T_CITY
FROM teachers
WHERE T_CITY IN (SELECT S_CITY FROM students);

Q102. Select teachers not from New York or Kolkata.

SELECT T_NAME, T_CITY
FROM teachers
WHERE T_CITY NOT IN ('New York', 'Kolkata');

Q103. Select students whose age is not between 18 and 19.

SELECT S_FULLNAME, S_AGE
FROM students
WHERE S_AGE NOT BETWEEN 18 AND 19;

Q104. Select teachers with salary between ₹50,000 and ₹70,000 and name in ('Alice Smith', 'Frank White').

SELECT T_NAME, T_SALARY
FROM teachers
WHERE T_SALARY BETWEEN 50000.000 AND 70000.00
AND T_NAME IN ('Alice Smith', 'Frank White');

Q105. Select teachers with salary between ₹50,000–₹70,000, named Alice or Frank, and from New York.

SELECT T_NAME, T_CITY, T_SALARY
FROM Teachers
WHERE T_SALARY BETWEEN 50000.00 AND 70000.00
  AND T_NAME IN ('Alice Smith', 'Frank White')
  AND T_CITY = 'New York';


Q106. Select teachers whose salary is between ₹50,000–₹70,000 OR name is 'Diana Prince' or 'Charlie Brown'.

SELECT T_NAME, T_SALARY
FROM Teachers
WHERE T_SALARY BETWEEN 50000.00 AND 70000.00
  OR T_NAME IN ('Diana Prince', 'Charlie Brown');


  --------------------
Q107. Create a table named library_teachers.

  CREATE TABLE libarey_teachers (
    L_ID INT NOT NULL PRIMARY KEY,
    L_NAME VARCHAR(255) NOT NULL,
    L_AGE INT,
    L_CITY VARCHAR(255),
    L_CLASS INT 
);

Q108. Create a Book table with a primary key.

CREATE TABLE IF NOT EXISTS Book (
    BookID INT NOT NULL,
    BookName VARCHAR(255) NOT NULL,
    BookPrice DECIMAL(10, 2),
    PRIMARY KEY (BookID)
);

Q109. Create an Orders_Books table with a composite primary key.

CREATE TABLE IF NOT EXISTS Orders_Books (
    OrderID INT NOT NULL,
    BookNumber INT NOT NULL,
    BookName VARCHAR(255),
    BookClass INT,
    PRIMARY KEY (OrderID, BookNumber)
);

ALTER TABLE orders_books
DROP PRIMARY KEY (BookNumber);
-------------------

SQL FOREIGN KEY

CREATE TABLE STUDENT(
     STUDENT_ID INT PRIMARY KEY,
     NAME VARCHAR(20),
     ADDRESS VARCHAR(20),
     AGE INT,
     DOB DATE);


# The SQL Unique Key
Unique Key is just an alternative to the Primary Key; as both Unique and Primary Key constraints ensure uniqueness in a column of the table.

Features of Unique Keys
    Following is the list of some key features of the Unique Key in an SQL database −

    The unique key is similar to the primary key in a table, but it can accept NULL values, whereas the primary key does not.

    It accepts only one NULL value.
    It cannot have duplicate values.
    It can also be used as a foreign key in another table.
    A table can have more than one Unique column.

The SQL UNIQUE constraint is used to ensure that all values in a column (or a combination of columns) are unique across all rows in a table.

While a PRIMARY KEY also enforces uniqueness, a table can have multiple UNIQUE constraints, whereas it can only have one PRIMARY KEY.

The SQL UNIQUE constraint is used to ensure that all values in a column (or a combination of columns) are unique across all rows in a table.

While a PRIMARY KEY also enforces uniqueness, a table can have multiple UNIQUE constraints, whereas it can only have one PRIMARY KEY.

Key Characteristics of a UNIQUE Constraint:
Uniqueness: Guarantees that no two rows will have the same value(s) in the specified column(s) covered by the UNIQUE constraint.

Multiple per Table: A table can have many UNIQUE constraints.

NULL Values: A UNIQUE column can contain NULL values. However, most database systems (including MySQL) treat NULL values as unique for the purpose of a UNIQUE constraint. This means you can typically have only one NULL value in a column with a UNIQUE constraint. If you try to insert a second NULL, it will often be rejected as a duplicate.

Index Creation: Similar to primary keys, a UNIQUE constraint automatically creates a unique index on the specified column(s), which helps in faster data retrieval.

#  Alternate Key: As discussed previously, any candidate key that is not chosen as the primary key is referred to as an "Alternate Key," and these are implemented using the UNIQUE constraint.

When to Use a UNIQUE Constraint:
When a column needs to uniquely identify records, but it's not the primary way you'll reference the record (e.g., Email address, SocialSecurityNumber, ProductCode).

When you want to prevent duplicate entries in a specific column, but that column might sometimes be NULL.

How to Create a UNIQUE Constraint
You can define a UNIQUE constraint when you create a table (CREATE TABLE) or add it to an existing table (ALTER TABLE).

The SQL UNIQUE constraint is used to ensure that all values in a column (or a combination of columns) are unique across all rows in a table.

While a PRIMARY KEY also enforces uniqueness, a table can have multiple UNIQUE constraints, whereas it can only have one PRIMARY KEY.

Key Characteristics of a UNIQUE Constraint:
Uniqueness: Guarantees that no two rows will have the same value(s) in the specified column(s) covered by the UNIQUE constraint.

Multiple per Table: A table can have many UNIQUE constraints.

NULL Values: A UNIQUE column can contain NULL values. However, most database systems (including MySQL) treat NULL values as unique for the purpose of a UNIQUE constraint. This means you can typically have only one NULL value in a column with a UNIQUE constraint. If you try to insert a second NULL, it will often be rejected as a duplicate.

Index Creation: Similar to primary keys, a UNIQUE constraint automatically creates a unique index on the specified column(s), which helps in faster data retrieval.

Alternate Key: As discussed previously, any candidate key that is not chosen as the primary key is referred to as an "Alternate Key," and these are implemented using the UNIQUE constraint.

When to Use a UNIQUE Constraint:
When a column needs to uniquely identify records, but it's not the primary way you'll reference the record (e.g., Email address, SocialSecurityNumber, ProductCode).

When you want to prevent duplicate entries in a specific column, but that column might sometimes be NULL.

How to Create a UNIQUE Constraint
You can define a UNIQUE constraint when you create a table (CREATE TABLE) or add it to an existing table (ALTER TABLE).

1. Defining UNIQUE During Table Creation (CREATE TABLE) 

    A) Column Level (Inline): Applies the constraint directly to a single column.
CREATE TABLE Users (
    UserID INT NOT NULL PRIMARY KEY,
    Username VARCHAR(50) NOT NULL UNIQUE, -- Username must be unique
    Email VARCHAR(255) UNIQUE,            -- Email must be unique (can be NULL once)
    PasswordHash VARCHAR(255)
);

B) Table Level (Out-of-line):
Useful for naming the constraint explicitly or for defining a composite unique key.

SQL

CREATE TABLE Products (
    ProductID INT NOT NULL PRIMARY KEY,
    ProductCode VARCHAR(20) NOT NULL,
    ProductName VARCHAR(255),
    CONSTRAINT UQ_ProductCode UNIQUE (ProductCode) -- Named unique constraint
);
C) Composite Unique Key (Multiple Columns):
Ensures the combination of values in specified columns is unique.

SQL

CREATE TABLE CourseRegistrations (
    RegistrationID INT NOT NULL PRIMARY KEY,
    StudentID INT NOT NULL,
    CourseID INT NOT NULL,
    RegistrationDate DATE,
    CONSTRAINT UQ_StudentCourse UNIQUE (StudentID, CourseID) -- A student can register for a course only once
);
2. Adding UNIQUE to an Existing Table (ALTER TABLE)
SQL

-- Add a UNIQUE constraint to the T_PHONE column in the Teachers table
ALTER TABLE Teachers
ADD CONSTRAINT UQ_TeacherPhone UNIQUE (T_PHONE);
3. Dropping a UNIQUE Constraint
You need to know the name of the constraint (if you named it) or the system-generated name.

SQL

ALTER TABLE YourTable
DROP INDEX UQ_YourColumnName; -- For MySQL, you drop the index
-- Or sometimes: ALTER TABLE YourTable DROP CONSTRAINT UQ_YourConstraintName;
(Note: In MySQL, a UNIQUE constraint is implemented as a UNIQUE INDEX, so you often drop the index.)


# PRIMARY KEY in SQL

PRIMARY KEY in SQL is a column (or group of columns) that uniquely identifies the records in that table. A primary key must contain unique values and can not have any NULL value.

There can only be one primary key in a table, but that primary key can consist of one or more columns. When there are two or more columns in the primary key it is called a composite key.

A primary key automatically has a UNIQUE constraint defined on it, and it ensures that there are no duplicate or NULL values in that column.

Creating an SQL Primary Key
CREATE TABLE CUSTOMERS (
   ID INT NOT NULL,
   NAME VARCHAR (20) NOT NULL,
   AGE INT NOT NULL,
   ADDRESS CHAR (25),
   SALARY DECIMAL (18, 2),       
   PRIMARY KEY (ID)
);

Creating Primary Key on an Existing Column
    ALTER TABLE table_name ADD CONSTRAINT PRIMARY KEY (column_name);
    ALTER TABLE CUSTOMERS ADD CONSTRAINT PRIMARY KEY(NAME);
Dropping an SQL Primary Key
    ALTER TABLE CUSTOMERS DROP PRIMARY KEY;




# FOREIGN KEY
The SQL FOREIGN KEY constraint is a crucial element in relational database design. It is used to link two tables together and maintain referential integrity.

A FOREIGN KEY in one table points to a PRIMARY KEY (or a UNIQUE key) in another table. The table containing the foreign key is called the child table, and the table containing the primary key is called the parent table (or referenced table).

Key Characteristics of a Foreign Key:
Referential Integrity: The primary purpose of a foreign key is to ensure that relationships between tables remain consistent. This means:

You cannot insert a row into the child table if its foreign key value does not exist in the parent table's primary key column.

You cannot delete a row from the parent table if there are matching rows in the child table (unless specific ON DELETE actions are defined).

You cannot update a primary key value in the parent table if there are matching rows in the child table (unless specific ON UPDATE actions are defined).

Links Tables: It explicitly defines the relationship between two tables, making the database schema clear and robust.

Can be NULL: Unlike a primary key, a foreign key column can contain NULL values, unless it is also defined as NOT NULL. If it's NULL, it means that the record in the child table is not currently related to any record in the parent table.

How to Create a Foreign Key
You can define a foreign key when you create a table (CREATE TABLE) or add it to an existing table (ALTER TABLE).

1. Defining Foreign Key During Table Creation (CREATE TABLE)
SQL

CREATE TABLE ParentTable (
    ParentID INT NOT NULL PRIMARY KEY,
    ParentName VARCHAR(255)
);

CREATE TABLE ChildTable (
    ChildID INT NOT NULL PRIMARY KEY,
    ChildName VARCHAR(255),
    ParentFK INT, -- This will be the foreign key
    FOREIGN KEY (ParentFK) REFERENCES ParentTable(ParentID)
);
2. Adding Foreign Key to an Existing Table (ALTER TABLE)
SQL

ALTER TABLE ChildTable
ADD CONSTRAINT FK_ChildTable_ParentTable -- Optional: name the constraint
FOREIGN KEY (ParentFK)
REFERENCES ParentTable(ParentID);

3. ON DELETE and ON UPDATE Actions
These clauses specify what happens to the child table's rows when the corresponding parent row is deleted or updated.

CASCADE: If the parent row is deleted/updated, the child rows are also deleted/updated.

SET NULL: If the parent row is deleted/updated, the foreign key column in the child row is set to NULL. (Requires the foreign key column to be nullable).

RESTRICT (Default): Prevents the deletion/update of a parent row if there are matching child rows.

NO ACTION: Similar to RESTRICT, but behavior can vary slightly depending on the database system.

SQL

CREATE TABLE ChildTableWithActions (
    ChildID INT NOT NULL PRIMARY KEY,
    ChildName VARCHAR(255),
    ParentFK INT,
    FOREIGN KEY (ParentFK) REFERENCES ParentTable(ParentID)
    ON DELETE CASCADE   -- If a parent is deleted, delete related children
    ON UPDATE CASCADE   -- If a parent's ID changes, update children's FK
);
Example Using Your Tables
Let's consider your Book and Orders_Books tables from the Canvas:

Book Table (Parent Table):

SQL

CREATE TABLE IF NOT EXISTS Book (
    BookID INT NOT NULL,
    BookName VARCHAR(255) NOT NULL,
    BookPrice DECIMAL(10, 2),
    PRIMARY KEY (BookID)
);
Orders_Books Table (Child Table):

SQL

CREATE TABLE IF NOT EXISTS Orders_Books (
    OrderID INT NOT NULL,
    BookNumber INT NOT NULL, -- This should reference BookID in the Book table
    BookName VARCHAR(255),   -- This is redundant if you join with Book table
    BookClass INT,
    PRIMARY KEY (OrderID, BookNumber)
);
Currently, Orders_Books.BookNumber is intended to refer to Book.BookID, but there's no explicit foreign key constraint.

Here's how you would add a foreign key constraint to Orders_Books to link BookNumber to Book.BookID:




-- Assuming ParentTable and ChildTable are already created without FKs,
-- or you are modifying existing tables.

-- Example 1: Add a Foreign Key to Orders_Books (linking BookNumber to Book.BookID)
-- This ensures that every BookNumber in Orders_Books must exist as a BookID in the Book table.
ALTER TABLE Orders_Books
ADD CONSTRAINT FK_OrdersBooks_Book -- Naming the constraint is good practice
FOREIGN KEY (BookNumber)
REFERENCES Book(BookID)
ON DELETE RESTRICT -- Default behavior: prevent deleting a book if it's in an order
ON UPDATE CASCADE; -- If a BookID changes, update it in Orders_Books

-- Example 2: Create a new table with a Foreign Key defined during creation
-- Let's create a 'TeacherAssignments' table that links to 'libarey_teachers'.
CREATE TABLE IF NOT EXISTS TeacherAssignments (
    AssignmentID INT NOT NULL PRIMARY KEY,
    L_ID INT NOT NULL, -- This will be the foreign key
    AssignmentDate DATE,
    Subject VARCHAR(255),
    FOREIGN KEY (L_ID) REFERENCES libarey_teachers(L_ID)
    ON DELETE CASCADE -- If a teacher is deleted, their assignments are also deleted
    ON UPDATE CASCADE -- If a teacher's ID changes, update assignments
);



CREATE TABLE Departments (
    DeptID INT NOT NULL PRIMARY KEY, -- Primary Key for Departments table
    DeptName VARCHAR(100) NOT NULL,
    DeptLocation VARCHAR(100)
);
CREATE TABLE Employees (
    EmpID INT NOT NULL PRIMARY KEY,
    EmpName VARCHAR(255) NOT NULL UNIQUE, -- EmpName is now an Alternate Key (UNIQUE)
    EmpSalary DECIMAL(10, 2),
    DeptID INT, -- This column will be our Foreign Key
    -- Define the FOREIGN KEY constraint
    CONSTRAINT FK_Employee_Department -- Optional: Name the foreign key constraint
    FOREIGN KEY (DeptID)             -- The column in THIS table that is the foreign key
    REFERENCES Departments(DeptID)   -- The parent table and its primary key column
    ON DELETE RESTRICT               -- Action if a parent row is deleted (prevent deletion by default)
    ON UPDATE CASCADE                -- Action if a parent's primary key is updated (update child's FK)
);

-- -------------------------------------------------------------------
-- Section 1: Update Existing Table (student) with a Foreign Key
-- -------------------------------------------------------------------

-- Add a new column to the 'student' table to link to 'libarey_teachers'
-- We'll call it Teacher_L_ID. It can be NULL if a student isn't assigned a library teacher.
ALTER TABLE student
ADD COLUMN Teacher_L_ID INT;

-- Add the FOREIGN KEY constraint to the 'student' table
-- This links student.Teacher_L_ID to libarey_teachers.L_ID
ALTER TABLE student
ADD CONSTRAINT FK_Student_LibraryTeacher
FOREIGN KEY (Teacher_L_ID)
REFERENCES libarey_teachers(L_ID)
ON DELETE SET NULL   -- If a library teacher is deleted, set student's Teacher_L_ID to NULL
ON UPDATE CASCADE;   -- If a library teacher's L_ID changes, update student's Teacher_L_ID

-- Update some students to assign them a Teacher_L_ID
-- Make sure the L_ID values (1, 2, 3) exist in your libarey_teachers table.
UPDATE student
SET Teacher_L_ID = 1
WHERE S_ID IN (1, 3); -- Assign John (L_ID 1) to Nasim and Joy

UPDATE student
SET Teacher_L_ID = 2
WHERE S_ID = 2; -- Assign Mary (L_ID 2) to Reja

UPDATE student
SET Teacher_L_ID = 3
WHERE S_ID IN (4, 6); -- Assign Paul (L_ID 3) to Alex and Mew

-- Verify the update (optional)
SELECT S_NAME, S_CITY, Teacher_L_ID FROM student;


-- -------------------------------------------------------------------
-- Section 2: Create a New Table (StudentBooks) with Multiple Foreign Keys
-- -------------------------------------------------------------------

-- Drop the table if it already exists to ensure a clean creation
DROP TABLE IF EXISTS StudentBooks;

-- Create the StudentBooks table
-- This table tracks which student borrowed which book.
CREATE TABLE StudentBooks (
    BorrowID INT NOT NULL PRIMARY KEY AUTO_INCREMENT, -- Auto-incrementing ID for each borrow record
    StudentID INT NOT NULL,
    BookID INT NOT NULL,
    BorrowDate DATE NOT NULL,
    ReturnDate DATE, -- Can be NULL if the book is not yet returned
    -- Composite UNIQUE constraint to prevent a student from borrowing the same book twice
    CONSTRAINT UQ_StudentBookBorrow UNIQUE (StudentID, BookID),

    -- Foreign Key to the 'student' table
    CONSTRAINT FK_StudentBooks_Student
    FOREIGN KEY (StudentID) REFERENCES student(S_ID)
    ON DELETE CASCADE   -- If a student is deleted, their borrow records are deleted
    ON UPDATE CASCADE,  -- If a student's S_ID changes, update borrow records

    -- Foreign Key to the 'Book' table
    CONSTRAINT FK_StudentBooks_Book
    FOREIGN KEY (BookID) REFERENCES Book(BookID)
    ON DELETE RESTRICT  -- Prevent deleting a book if it's currently borrowed
    ON UPDATE CASCADE   -- If a BookID changes, update borrow records
);

-- Insert Sample Data into StudentBooks
INSERT INTO StudentBooks (StudentID, BookID, BorrowDate, ReturnDate)
VALUES
    (1, 101, '2024-06-01', '2024-06-15'), -- Nasim borrowed Adventure
    (2, 103, '2024-06-05', NULL),         -- Reja borrowed History (not returned yet)
    (3, 102, '2024-06-10', '2024-06-20'), -- Joy borrowed Science
    (4, 104, '2024-06-12', NULL),         -- Alex borrowed Math (not returned yet)
    (1, 105, '2024-06-18', NULL),         -- Nasim borrowed Art (another book)
    (5, 106, '2024-06-20', '2024-06-25'), -- Bob borrowed Fiction
    (6, 107, '2024-06-22', NULL);         -- Mew borrowed Poetry (not returned yet)

-================================================================

# Features of Foreign Key
Following is the of features of Foreign Key −

A Foreign Key is used to reduce the redundancy (or duplicates) in the table.

It helps to normalize (or organize the data in a database) the data in multiple tables.

Syntax
Following is the basic syntax to add Foreign Key constraints on a column of a table in MySQL database −

CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
    CONSTRAINT fk_name 
	FOREIGN KEY (column_name) 
	REFERENCES referenced_table(referenced_column)
);
Example
Let us create two tables with the names CUSTOMERS and ORDERS. The following query creates a table with the name CUSTOMERS −

CREATE TABLE CUSTOMERS(
   ID INT NOT NULL,
   NAME VARCHAR (20) NOT NULL,
   AGE INT NOT NULL,
   ADDRESS CHAR (25) ,
   SALARY DECIMAL (18, 2),       
   PRIMARY KEY (ID)
);

Now, let us create the ORDERS table. While doing so, we add the foreign key constraint on column CUSTOMER_ID reference on column ID of the CUSTOMERS table as shown in the statement below −

CREATE TABLE ORDERS (
   ID INT NOT NULL,
   DATE DATETIME, 
   CUSTOMER_ID INT,
   CONSTRAINT FK_CUSTOMER 
   FOREIGN KEY(CUSTOMER_ID) 
   REFERENCES CUSTOMERS(ID),
   AMOUNT DECIMAL,
   PRIMARY KEY (ID)
);

Syntax
Using the ALTER TABLE statement we can add a Foreign Key constraint on an existing column in a table in MySQL database as shown below −

ALTER TABLE TABLE2 
ADD CONSTRAINT[symbol] 
FOREIGN KEY(column_name) 
REFERENCES TABLE1(column_name);
Here, FK_ORDERS is the name of the foreign key constraint. It is optional to specify the name of a constraint but it comes in handy while dropping the constraint.

Example
Assume the CUSTOMERS and ORDERS tables have already been created in the SQL database. Now, we will add a Foreign Key Constraint on the ID column of the ORDERS table.

Following is the SQL query to add the foreign key constraint on an the column of an existing table −

ALTER TABLE ORDERS 
ADD CONSTRAINT FK_ORDERS 
FOREIGN KEY(ID) 
REFERENCES CUSTOMERS(ID);
Output


Dropping a FOREIGN KEY
You can drop the foreign key from a table, without dropping that entire table, using the ALTER TABLE statement.

Syntax
Following is the syntax to drop the FOREIGN key constraint from the column of the table using the ALTER TABLE statement−

ALTER TABLE table_name DROP FOREIGN KEY (constraint symbol);
Where, FK_NAME is the name of the foreign key constraint you need to drop.

Example
The SQL query to drop the foreign key constraint from the column of a table is as follows −

ALTER TABLE ORDERS DROP FOREIGN KEY FK_ORDERS;
Output

-----------------------------------------------------------------------------------------------------
Primary Key                                 | |          Foreign Key
The primary key is always unique.	         |  The foreign key can be duplicated.
The primary key can not be NULL.	         |  The Foreign can be NULL.
A table can contain only one Primary Key.	 |  We can have more than one Foreign Key per table.
-----------------------------------------------------------------------------------------------------

CREATE TABLE STUDENT(
     STUDENT_ID INT PRIMARY KEY,
     NAME VARCHAR(20),
     ADDRESS VARCHAR(20),
     AGE INT,
     DOB DATE);

      CREATE TABLE COURSES(
     COURSE_NAME VARCHAR(20),
     INSTRUCTOR VARCHAR(20),
     REFERENCE_ID INT,
     CONSTRAINT FK_REFER FOREIGN KEY (REFERENCE_ID)
     REFERENCES STUDENT(STUDENT_ID));


     CREATE TABLE Customers (
  CustomerID INT PRIMARY KEY,
  CustomerName VARCHAR(50) NOT NULL
);

CREATE TABLE Orders (
  OrderID INT PRIMARY KEY,
  OrderNumber INT NOT NULL,
  CustomerID INT,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

INSERT INTO Customers (CustomerID, CustomerName)
VALUES (1, 'John'), (2, 'Jane'), (3, 'Bob');

INSERT INTO Orders (OrderID, OrderNumber, CustomerID)
VALUES (1, 101, 1), (2, 102, 2), (3, 103, 3);
----------------------------


# The SQL Join Clause

CREATE TABLE CUSTOMERS (
   ID INT NOT NULL,
   NAME VARCHAR (20) NOT NULL,
   AGE INT NOT NULL,
   ADDRESS CHAR (25),
   SALARY DECIMAL (18, 2),       
   PRIMARY KEY (ID)
);
CREATE TABLE ORDERS (
   OID INT NOT NULL,
   DATE VARCHAR (20) NOT NULL,
   CUSTOMER_ID INT NOT NULL,
   AMOUNT DECIMAL (18, 2)
);

SELECT ID, NAME, AGE, AMOUNT
FROM CUSTOMERS
JOIN ORDERS
ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID;

------------------
Types of joins in SQL
1. Inner Join

Basic Syntax:

SELECT column_list
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;

------------
-- Create the Products table

CREATE TABLE Products (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(255) NOT NULL,
    Price DECIMAL(10, 2) NOT NULL,
    StockQuantity INT NOT NULL
);

-- Insert data into Products

INSERT INTO Products (ProductID, ProductName, Price, StockQuantity) VALUES
(101, 'Laptop Pro', 1200.00, 50),
(102, 'Gaming Mouse', 45.50, 200),
(103, 'Mechanical Keyboard', 89.99, 150),
(104, 'External SSD 1TB', 99.00, 80),
(105, 'Webcam HD', 35.00, 100),
(999, 'Mystery Item', 50.00, 10);

CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT NOT NULL,
    OrderDate DATE NOT NULL,
    ProductID INT NOT NULL, -- This will link to the Products table
    Quantity INT NOT NULL,
    TotalAmount DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID)
);

INSERT INTO Orders (OrderID, CustomerID, OrderDate, ProductID, Quantity, TotalAmount) VALUES
(1, 1001, '2025-06-10', 101, 1, 1200.00),
(2, 1002, '2025-06-11', 103, 2, 179.98),
(3, 1001, '2025-06-12', 102, 3, 136.50),
(4, 1003, '2025-06-13', 104, 1, 99.00),
(5, 1004, '2025-06-14', 101, 1, 1200.00),
(6, 1005, '2025-06-15', 105, 2, 70.00),
(7, 1006, '2025-06-16', 999, 1, 50.00);

Question 1:
Retrieve a list of all orders, showing the OrderID, the ProductName of the item ordered, and the Quantity ordered.

Answer 1:
SELECT 
	orders.OrderID,
	products.ProductName,
	orders.Quantity
FROM orders
INNER JOIN 
products ON orders.ProductID = products.ProductID;

Explanation in Detail:

SELECT orders.OrderID, products.ProductName, orders.Quantity:

This is the SELECT clause, which determines what data you want to retrieve from the database.

orders.OrderID: You are asking for the OrderID column, specifically from the orders table. This is important because if both tables had a column with the same name (e.g., ID), you'd need to specify which table it comes from.

products.ProductName: You are requesting the ProductName column from the products table.

orders.Quantity: You are requesting the Quantity column from the orders table.

FROM orders:

This specifies the primary table from which you are starting your query. In this join, orders is considered the "left" table.

INNER JOIN products:

This is the core of the join operation.

INNER JOIN: This keyword indicates that you want to combine rows from orders and products where there are matching values in a specified column in both tables.

products: This is the second table involved in the join, considered the "right" table.

ON orders.ProductID = products.ProductID:

This is the join condition. It tells the database how to match rows between the orders table and the products table.

orders.ProductID: Refers to the ProductID column in the orders table (which is a foreign key).

products.ProductID: Refers to the ProductID column in the products table (which is the primary key).

The INNER JOIN will only return rows where the value in orders.ProductID is exactly the same as the value in products.ProductID. If an OrderID in the orders table has a ProductID that does not exist in the products table, that OrderID will be completely excluded from the final result set.

In simple terms, this query is asking:

"Show me the order number, the name of the product that was ordered, and how many of that product were ordered. Do this by looking at all sales orders, and for each order, find the corresponding product details by matching the Product IDs between the order and the product list. Only show me orders where the product actually exists in my product inventory."